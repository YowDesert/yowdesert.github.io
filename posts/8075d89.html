<!DOCTYPE html><html lang="zh-TW"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>(作業系統) Virtual Memory Operation | YD's 資訊學習筆記</title><meta name="author" content="YowDesert"><meta name="copyright" content="YowDesert"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="快速導覽 讓程式覺得自己有很大的連續記憶體（Virtual Address Space），但實際上只把「目前真的會用到的那部分」放在 RAM。 不夠的時候再把頁面換進換出（paging in&#x2F;out）。  Virtual Memory &#x3D; 用「需求載入（demand paging）」+「頁面置換（page replacement）」來用小 RAM 撐起大程式。    為什麼 VM 可行？  因為程">
<meta property="og:type" content="article">
<meta property="og:title" content="(作業系統) Virtual Memory Operation">
<meta property="og:url" content="https://yowdesert.github.io/posts/8075d89.html">
<meta property="og:site_name" content="YD&#39;s 資訊學習筆記">
<meta property="og:description" content="快速導覽 讓程式覺得自己有很大的連續記憶體（Virtual Address Space），但實際上只把「目前真的會用到的那部分」放在 RAM。 不夠的時候再把頁面換進換出（paging in&#x2F;out）。  Virtual Memory &#x3D; 用「需求載入（demand paging）」+「頁面置換（page replacement）」來用小 RAM 撐起大程式。    為什麼 VM 可行？  因為程">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://yowdesert.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-12-20T13:15:00.000Z">
<meta property="article:modified_time" content="2025-12-20T17:41:15.270Z">
<meta property="article:author" content="YowDesert">
<meta property="article:tag" content="作業系統">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yowdesert.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "(作業系統) Virtual Memory Operation",
  "url": "https://yowdesert.github.io/posts/8075d89.html",
  "image": "https://yowdesert.github.io/img/butterfly-icon.png",
  "datePublished": "2025-12-20T13:15:00.000Z",
  "dateModified": "2025-12-20T17:41:15.270Z",
  "author": [
    {
      "@type": "Person",
      "name": "YowDesert",
      "url": "https://YowDesert.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yowdesert.github.io/posts/8075d89.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="google5c543dcf16a66e3c.html"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-5975504062599634',
  enable_page_level_ads: 'true'
});</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '複製成功',
    error: '複製失敗',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切換為繁體中文","cht_to_chs":"已切換為簡體中文","day_to_night":"已切換為深色模式","night_to_day":"已切換為淺色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '載入更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '(作業系統) Virtual Memory Operation',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="YD's 資訊學習筆記" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/backgroundPic.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/nav_Picture.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/Top.png" alt="Logo"><span class="site-name">YD's 資訊學習筆記</span></a><a class="nav-page-title" href="/"><span class="site-name">(作業系統) Virtual Memory Operation</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首頁</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">(作業系統) Virtual Memory Operation</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2025-12-20T13:15:00.000Z" title="發表於 2025-12-20 21:15:00">2025-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-12-20T17:41:15.270Z" title="更新於 2025-12-21 01:41:15">2025-12-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/">作業系統</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/Memory-Management/">Memory Management</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">總字數:</span><span class="word-count">4.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時間:</span><span>17分鐘</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>快速導覽</h1>
<p>讓程式覺得自己有很大的連續記憶體（Virtual Address Space），但實際上只把「目前真的會用到的那部分」放在 RAM。<br>
不夠的時候再把頁面換進換出（paging in/out）。</p>
<blockquote>
<p>Virtual Memory = 用「需求載入（demand paging）」+「頁面置換（page replacement）」來用小 RAM 撐起大程式。</p>
</blockquote>
<ul>
<li>
<p>為什麼 VM 可行？</p>
<ul>
<li>因為程式有 locality of reference（只會密集使用一小段頁面）。</li>
</ul>
</li>
<li>
<p>Demand Paging 是怎麼運作的？</p>
<ul>
<li>page table 的 valid/invalid bit + page fault 例外處理流程。</li>
</ul>
</li>
<li>
<p>Page fault 為什麼會讓效能炸掉？</p>
<ul>
<li>因為牽涉 disk I/O，所以 page fault rate 要非常非常小；會用 EAT（effective access time） 去算。</li>
</ul>
</li>
<li>
<p>沒有 free frame 時怎麼辦？</p>
<ul>
<li>用 page replacement，挑 victim page；dirty 的還要先寫回。</li>
</ul>
</li>
<li>
<p>frames 要怎麼分配給 process？</p>
<ul>
<li>有 minimum frames（不然某些指令會永遠做不完），再來談 equal/proportional/priority、local/global replacement。</li>
</ul>
</li>
<li>
<p>什麼是 thrashing？怎麼救？</p>
<ul>
<li>一直在換頁，CPU 利用率反而下降。用 working-set model 或 page-fault frequency (PFF) 控制/暫停部分 process。</li>
</ul>
</li>
</ul>
<hr>
<h1>BackGround</h1>
<p>The Problem - <strong>Wasteful Memory Usage</strong></p>
<h2 id="Why-Use-VM">Why Use VM</h2>
<p>傳統 : 整個程式載入Memory</p>
<ul>
<li>問題 : 很多當前沒用到的程式
<ul>
<li>Error Handling : 很少觸發，但碼量很大 → 佔 RAM</li>
<li>Infrequent Features : 基本用不到的功能 → 佔 RAM</li>
<li>Over-Allocated Structures : array/buffer 宣告最大值，但實際只用一小部分 → 佔 RAM</li>
</ul>
</li>
</ul>
<p>Key Insight：Locality of Reference</p>
<ul>
<li>程式在任何時間點，只會用到位址空間的<strong>一小部分</strong>
<ul>
<li>Temporal locality（時間區域性）：剛用過的，等一下還會用（例如 loop 變數、同一段 code 重複跑）</li>
<li>Spatial locality（空間區域性）：用到 A 之後，很可能用到 A 附近（例如陣列連續存取、順序指令）</li>
</ul>
</li>
<li>這少部分放在 <strong>working set</strong> 剩下可以放Disk</li>
</ul>
<p>把 logical (virtual)<strong>address space</strong> 和 <strong>physical address space</strong> 分開。</p>
<ul>
<li>程式使用的是 virtual address（可以很大）</li>
<li>OS 只把 需要的那部分對應（map）到 RAM</li>
<li>沒用到的那部分 留在 disk，等真的用到再載入</li>
</ul>
<h2 id="VM-解決-Memory-4-Problem">VM 解決 Memory 4 Problem</h2>
<table>
<thead>
<tr>
<th>Problem</th>
<th>VM解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unused code</td>
<td>demand loading</td>
</tr>
<tr>
<td>Redundant Libraries</td>
<td>sharing</td>
</tr>
<tr>
<td>Over-alloc</td>
<td>保留很大一段虛擬位址空間，真正碰到那段才給 physical page</td>
</tr>
<tr>
<td>Program &gt; RAM</td>
<td>partial execution (swap in/out)</td>
</tr>
</tbody>
</table>
<h2 id="VM-Benefits">VM Benefits</h2>
<ol>
<li><strong>Larger Processes</strong></li>
<li>Higher Multiprogramming - RAM 可放更多 Process 的 Working Set → CPU/資源利用率更好</li>
<li><strong>Simplified</strong> Programming</li>
<li><strong>Faster</strong> Execution - Less I/O</li>
</ol>
<h2 id="Implementation">Implementation</h2>
<ul>
<li><strong>Demand Paging</strong>（常見）：固定大小 pages，管理簡單（主流就是它）</li>
<li>Demand Segmentation（較少）：可變大小 segments，管理複雜</li>
</ul>
<hr>
<h1>Demand Paging</h1>
<h2 id="基礎概念">基礎概念</h2>
<p>Demand Paging =<strong>「用到才載入」</strong></p>
<p>Benifits :</p>
<ol>
<li>Less I/O</li>
<li>Less memory per process</li>
<li>Large programs</li>
</ol>
<p>運作 :</p>
<ul>
<li>CPU 要存取某 page → 查 page table：
<ul>
<li>valid = 1：代表這個 page 在 RAM → 直接存取（hit）</li>
<li>valid = 0：代表「不在 RAM / 或不合法」
<ul>
<li>若是 invalid reference（不合法位址） → OS 終止（abort）</li>
<li>是 合法但尚未載入 → 觸發 page fault（OS 去把 page 載進來）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>流程 :</p>
<ol>
<li>
<p>Step 1：初始化 process 控制結構</p>
<ul>
<li>
<p>建 PCB、設定 PC、初始化 registers</p>
</li>
<li>
<p>建 page table：先把 entries 標成 invalid（表示目前沒載入）</p>
</li>
</ul>
</li>
<li>
<p>Step 2：只載入必要頁</p>
<ul>
<li>只載入「第一個 code page」（包含 entry point 的那頁）</li>
</ul>
</li>
<li>
<p>Step 3：開始執行</p>
<ul>
<li>
<p>CPU 取指令（fetch at PC）</p>
</li>
<li>
<p>如果要用到的 page 不在 RAM → page fault → OS 把缺的 page 載入</p>
</li>
</ul>
</li>
<li>
<p>Step 4：結束 : Free</p>
</li>
</ol>
<h2 id="Pure-Demand-Paging">Pure Demand Paging</h2>
<p><strong>一開始 0 個 pages 在 RAM</strong></p>
<p>流程 :</p>
<ol>
<li>放「不在 RAM 的 pages」的地方</li>
<li>CPU 抓第一個instruction → page fault → Load code space</li>
<li>Access Data →  page fault → Load data page</li>
<li>用到哪載哪</li>
</ol>
<p>Trade-off :</p>
<ul>
<li>Pro（優點）：一開始佔用 RAM 最少</li>
<li>Con（缺點）：剛開始 page fault 率會很高</li>
</ul>
<p>但靠 <strong>locality</strong> 快速 warm-up 穩定</p>
<h2 id="Pager-v-s-Swapper">Pager v.s Swapper</h2>
<p>Pager : 管理 <strong>「單一 page」</strong> 的載入/換出 （demand paging 用它）<br>
Swapper :搬移 <strong>「整個 process」</strong></p>
<p>Hardware requirements</p>
<ul>
<li>Page table valid/invalid bit
<ul>
<li>1：page 在 memory</li>
<li>0：page 在 disk / 尚未載入</li>
</ul>
</li>
</ul>
<p>Swap space / backing store（後備儲存）: 放「不在 RAM 的 pages」的地方</p>
<h2 id="Page-Fault-Handling">Page Fault Handling</h2>
<p>process 存取某 page 時，發現 <strong>valid bit = 0</strong> → 硬體觸發 <strong>trap</strong> 進 OS</p>
<p>流程 :</p>
<blockquote>
<p>trap→驗證→找 frame→從 disk 載→更新表→重啟指令</p>
</blockquote>
<ol>
<li>
<p>Trap to OS</p>
<ul>
<li>
<p>保存狀態（PC、registers）</p>
</li>
<li>
<p>呼叫 page fault handler</p>
</li>
</ul>
</li>
<li>
<p>Validate reference（判斷是不是合法位址）</p>
<ul>
<li>
<p>不合法 → ABORT（segmentation fault）</p>
</li>
<li>
<p>合法但不在 memory → 繼續處理</p>
</li>
</ul>
</li>
<li>
<p>Get free frame</p>
<ul>
<li>
<p>從 free-frame list 拿</p>
</li>
<li>
<p>若沒有 → 之後會用 <strong>page replacement</strong></p>
</li>
</ul>
</li>
<li>
<p>Load page from disk : 去 swap space 找到 page，讀進 RAM</p>
</li>
<li>
<p>Update page table : 寫入 frame number，並把 valid 設成 1</p>
</li>
<li>
<p>Restart instruction</p>
</li>
</ol>
<h2 id="Page-Replacement">Page Replacement</h2>
<p>page fault 發生時，如果 沒有 free frames，就必須先「趕走一個 page」</p>
<p>流程 :</p>
<ol>
<li>
<p>選 victim page（用 replacement algorithm：FIFO/LRU/Clock…）</p>
</li>
<li>
<p>如果 victim 是 dirty → 先寫回 disk</p>
<blockquote>
<p>dirty : RAM 內容 ≠ backing store（disk/swap）上的內容</p>
</blockquote>
</li>
<li>
<p>把新 page 從 disk 載入剛空出來的 frame</p>
</li>
<li>
<p>更新 page tables</p>
<ul>
<li>
<p>victim：valid = 0</p>
</li>
<li>
<p>new page：valid = 1</p>
</li>
</ul>
</li>
<li>
<p>restart instruction</p>
</li>
</ol>
<p>Cost :</p>
<ul>
<li>Clean victim：1 次 disk read（只要把新 page 讀進來）</li>
<li>Dirty victim：<strong>1 write</strong> + 1 read（先寫回再讀新頁）</li>
</ul>
<h2 id="Demand-Paging-Performance">Demand Paging Performance</h2>
<p>EAT 公式 :<br>
$$<br>
EAT = (1-p) * ma + p * pft<br>
$$</p>
<blockquote>
<p>p = page fault rate , ma = memory access time , pft = page fault time</p>
</blockquote>
<h2 id="Why-Demand-Paging-Works">Why Demand Paging Works</h2>
<p>Locality again（空間 + 時間都 <strong>「靠近」</strong>）</p>
<ul>
<li>Spatial：存取 X → 很快會用到附近位址（陣列 traversal）</li>
<li>Temporal：存取 X → 很快又會用到 X（迴圈變數）</li>
</ul>
<p>Locality 怎麼降低 page faults ?</p>
<ul>
<li>一次 page fault 載入的是 <strong>「整個 page」</strong></li>
</ul>
<h2 id="page-fault-為什麼這麼慢？">page fault 為什麼這麼慢？</h2>
<p>Page fault time ，主要分四段</p>
<ol>
<li>
<p>Service interrupt：~10µs（0.1%）</p>
</li>
<li>
<p>Find frame &amp; locate page：~100µs（1.2%）</p>
</li>
<li>
<p>Disk I/O：~7.9ms（98.5%）← 超大瓶頸</p>
<ul>
<li>seek + rotation + transfer</li>
</ul>
</li>
<li>
<p>Restart process：~10µs（0.1%）</p>
</li>
</ol>
<blockquote>
<p>1,2,4 可壓到幾百條指令 , Disk I/O 最難縮</p>
</blockquote>
<hr>
<h1>Process Creation</h1>
<table>
<thead>
<tr>
<th>機制</th>
<th>核心想法（一句話）</th>
<th>觸發時機（什麼時候才真的做事）</th>
<th>主要優點</th>
<th>主要代價 / 注意點</th>
</tr>
</thead>
<tbody>
<tr>
<td>Demand Paging for Process Creation（建立行程也按需載入）</td>
<td><strong>建立 process 時不把整個程式載入 RAM</strong>，只先載「會馬上用到」的 page</td>
<td><strong>CPU 執行到尚未載入的 page → page fault → OS 把該 page 從磁碟載入</strong></td>
<td>啟動更快、RAM 壓力更小、可同時容納更多 process（提高 multiprogramming）</td>
<td>會有較多 page fault（尤其剛開始/工作集變動時）；page fault 很貴（牽涉 I/O）</td>
</tr>
<tr>
<td>Copy-on-Write（COW）</td>
<td><code>fork()</code> 時先<strong>共享</strong> parent 的 pages，<strong>有人要寫才複製</strong></td>
<td><code>fork()</code> 後 <strong>第一次寫入某個共享 page → protection fault（常見：write fault）→ OS 複製該 page 給寫入者</strong></td>
<td><code>fork()</code> 便宜很多；如果 child 很快 <code>exec()</code>，幾乎不用真的複製（超省）</td>
<td>第一次寫入會有額外成本；需要頁面保護/引用計數等機制；寫很多時最後仍可能接近「全拷貝」成本</td>
</tr>
<tr>
<td>Memory-Mapped Files（MMF / mmap）</td>
<td>把<strong>檔案內容映射成一段 virtual memory</strong>，像存取陣列一樣讀寫檔案</td>
<td><strong>第一次碰到某段檔案對應的 page → page fault → OS 把檔案那段讀進 page cache / 記憶體</strong>；寫入通常也會變成「Dirty」之後再回寫</td>
<td>少很多 <code>read()/write()</code> 系統呼叫；OS 可用 page cache 做快取；支援 shared mapping（多 process 共享同一份檔案資料）</td>
<td>需要處理一致性/同步；SIGBUS/檔案截斷等邊界情況；不小心會變成隱性大量 page fault</td>
</tr>
</tbody>
</table>
<blockquote>
<p>COW 簡單說就是 只複製有改動的地方 ， 令 Page A,B,C ，Process 改 Page C ，那就複製一個出來給他 ，其他共用。</p>
</blockquote>
<hr>
<h1>Page Replacement</h1>
<p>觸發情境：page fault + 沒有 free frames</p>
<p>Two solution :</p>
<ul>
<li>
<p>Option 1：Swap out entire process（把整個行程換出去）</p>
<ul>
<li>做法：挑一個 victim process，把它所有 frames 都釋放</li>
<li>缺點：一次釋放很多 frame 沒錯，但你把一個 process 直接踢走 → multiprogramming degree 下降</li>
</ul>
</li>
<li>
<p>Option 2：Page replacement</p>
<ul>
<li>做法：只踢掉 一個 page（或少量 pages）來空出 frame</li>
<li>優點：仍然維持多行程程度（multiprogramming level）</li>
</ul>
<blockquote>
<p>這裡提到 dirty bit：想省成本就「偏好換掉 clean page」，因為 dirty page 換出前要先寫回 disk（多一次 I/O）</p>
</blockquote>
</li>
<li>
<p>Frame allocation algorithm：<strong>每個 process 分到幾個 frames</strong>？</p>
<ul>
<li>少 → page fault rate 高 → thrashing</li>
<li>太多 → 記憶體浪費、同時能放的 process 變少（multiprogramming 降）</li>
</ul>
</li>
</ul>
<p>page fault 流程 = 找 disk 位置 → 找 frame（沒就 replacement：選victim/dirty寫回/改PTE invalid）→ 讀入 → 更新 page+frame table → 重啟指令。</p>
<h2 id="Page-Replacement-Algorithms">Page Replacement Algorithms</h2>
<p>Goal：<strong>最小化 page fault rate</strong> → <strong>減少 disk I/O</strong> → 整體效能更好</p>
<p>Time-based Algorithm</p>
<ul>
<li>FIFO：最早進來的先出去（oldest page）</li>
<li>Optimal (OPT/MIN)：換掉「未來最久才會再被用到」的 page</li>
<li>LRU：換掉「最久沒被用到」的 page</li>
</ul>
<p>Frequency-based</p>
<ul>
<li>LFU：換掉「被存取次數最少」的 page</li>
<li>MFU：換掉「被存取次數最多」的 page</li>
</ul>
<h2 id="FIFO">FIFO</h2>
<p>換掉<strong>最早被載入</strong>記憶體的 page（oldest）</p>
<p>怎麼做 :</p>
<ul>
<li>用一個 queue 記錄「進來順序」</li>
<li>page fault 且要換頁：
<ul>
<li>踢掉 queue front（最老）</li>
<li>新 page 放 queue rear（最新）</li>
</ul>
</li>
</ul>
<h2 id="FIFO-的-Belady’s-Anomaly">FIFO 的 Belady’s Anomaly</h2>
<p>直覺 vs 現實</p>
<ul>
<li>直覺：frames 更多 → page faults 應該更少 ✅</li>
<li>FIFO 現實：frames 更多 → page faults 反而更多 ❌<br>
這個反直覺現象叫 Belady’s anomaly。</li>
</ul>
<p>為什麼會發生？</p>
<ul>
<li>因為 FIFO 不保證「frames 變多時，記憶體裡的 pages 集合是包含關係」。<br>
多一個 frame 會改變「老舊順序」，可能害你把之後需要的頁踢掉。</li>
</ul>
<h2 id="OPT-MIN-Belady’s-Algorithm">OPT / MIN / Belady’s Algorithm</h2>
<p>換掉 **「未來最久才會再被用到」**的那個 page<br>
需要「知道未來」→ 現實做不到</p>
<h2 id="LRU（Least-Recently-Used）">LRU（Least Recently Used）</h2>
<p>OPT 看未來（forward）不可能</p>
<p>LRU 改成看過去（backward）：<strong>換掉最久沒被用的 page</strong></p>
<p>LRU 怎麼實作 :</p>
<ul>
<li>方法1：Counter / Timestamp
<ul>
<li>每次 access：更新該 page 的 timestamp</li>
<li>要換頁：找 timestamp 最小的（最久以前）</li>
<li>成本：更新 O(1)，但找最小值要 O(n) → <strong>太慢</strong></li>
</ul>
</li>
<li>方法2：Stack（雙向鏈結串列）
<ul>
<li>每次 access：把該 page 移到串列最上面（MRU）</li>
<li>換頁：直接拿最下面（LRU）</li>
<li>若有 hash table 做 page→node 查找：
<ul>
<li>更新可接近 O(1)，換頁 <strong>O(1)</strong></li>
</ul>
</li>
<li>但問題是：每次 memory access 都要動資料結構 → <strong>overhead 太大</strong></li>
</ul>
</li>
</ul>
<h2 id="Stack-Algorithms">Stack Algorithms</h2>
<p>n frames 時在 memory 的 pages 集合，一定是 (n+1 frames) 的子集合<br>
也就是：Pages(n) ⊆ Pages(n+1)</p>
<blockquote>
<p>Stack algorithms 不會有 Belady’s anomaly<br>
OPT 和 LRU 都是 stack algorithm<br>
FIFO 不是，所以會 anomaly。</p>
</blockquote>
<h2 id="LRU-Approximation：Reference-Bit">LRU Approximation：Reference Bit</h2>
<p>True LRU 要「每次存取都更新資料結構」→ 太貴</p>
<p>解法：用硬體的 Reference bit（R-bit）</p>
<ul>
<li>
<p>每個 page 有 R bit</p>
</li>
<li>
<p>初始 R=0</p>
</li>
<li>
<p>page 被存取時：硬體自動設 R=1</p>
</li>
<li>
<p>OS 週期性把 R 清回 0</p>
<ul>
<li>R=1 表示「最近被用過」</li>
<li>R=0 表示「最近沒用」</li>
</ul>
</li>
</ul>
<h2 id="LRU-Approximation-的三個演算法">LRU Approximation 的三個演算法</h2>
<p><strong>Additional-Reference-Bits</strong></p>
<ul>
<li>用「多個 bit」記錄一段時間的 history（像移位暫存器）</li>
<li>bits 越多越像 LRU，但成本也更高（需要更多記憶體/維護）</li>
</ul>
<p><strong>Second-Chance / Clock</strong></p>
<ul>
<li>用單一 R bit</li>
<li>概念：FIFO + second chance
<ul>
<li>看到某 page 若 R=1：給它一次機會 → 把 R 清成 0、指標往下</li>
<li>若 R=0：就換掉它</li>
</ul>
</li>
<li>最常見、CP值最好</li>
</ul>
<p><strong>Enhanced Second-Chance</strong></p>
<ul>
<li>用 (R bit + dirty bit)</li>
<li>優先換掉「(R=0, dirty=0)」這種：最近沒用且乾淨（不用寫回）</li>
<li>I/O 效能更好</li>
</ul>
<h2 id="Frequency-Based-不常用">Frequency-Based (不常用)</h2>
<p>用 **「頻率」**不是「最近性」</p>
<p>LFU：換掉 count 最小（最少用）</p>
<p>MFU：換掉 count 最大（最常用）</p>
<h2 id="總結表格">總結表格</h2>
<table>
<thead>
<tr>
<th>演算法</th>
<th>替換規則（踢誰）</th>
<th>需要硬體/資料結構</th>
<th>優點</th>
<th>缺點/考點</th>
<th>是否可能 Belady anomaly</th>
<th>投影片例子 faults</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIFO</td>
<td>踢最老（最早進來）</td>
<td>Queue</td>
<td>超簡單</td>
<td>不看 locality，可能踢掉常用頁</td>
<td><strong>會</strong></td>
<td>3 frames → 9；4 frames → 10</td>
</tr>
<tr>
<td>OPT / MIN</td>
<td>踢「未來最久才用」</td>
<td>需要未來資訊（不可實作）</td>
<td>理論最佳（下界）</td>
<td>實務做不到，只能比較</td>
<td><strong>不會</strong>（stack)</td>
<td>4 frames → 6</td>
</tr>
<tr>
<td>LRU</td>
<td>踢「最久沒用」</td>
<td>追蹤 recency（昂貴）</td>
<td>locality 很合理，常近似 OPT</td>
<td>True LRU 成本高 → 需近似</td>
<td><strong>不會</strong>（stack)</td>
<td>4 frames → 8</td>
</tr>
<tr>
<td>Clock / Second chance</td>
<td>FIFO + R bit：R=1 給一次機會，R=0 才踢</td>
<td>1-bit R + circular pointer</td>
<td>CP值最高，常用</td>
<td>只是近似 LRU</td>
<td>通常不會像 FIFO 那麼糟（課本常視為 stack 近似）</td>
<td>（投影片未給數）</td>
</tr>
<tr>
<td>Enhanced Clock</td>
<td>按 (R,dirty) 類別優先踢 (0,0)</td>
<td>R bit + dirty bit</td>
<td>少寫回，I/O 更好</td>
<td>複雜一點</td>
<td>同上</td>
<td>—</td>
</tr>
<tr>
<td>LFU</td>
<td>踢 count 最小</td>
<td>counter</td>
<td>直覺：常用留著</td>
<td>phase change 容易失準；需 aging</td>
<td>不一定</td>
<td>—</td>
</tr>
<tr>
<td>MFU</td>
<td>踢 count 最大</td>
<td>counter</td>
<td>另一種假設（最小可能剛進來）</td>
<td>多數情況不穩、少用</td>
<td>不一定</td>
<td>—</td>
</tr>
</tbody>
</table>
<p>LRU 實作方法比較</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>怎麼做</th>
<th style="text-align:right">Access 成本</th>
<th style="text-align:right">換頁時找 victim 成本</th>
<th>問題</th>
</tr>
</thead>
<tbody>
<tr>
<td>Timestamp / Counter</td>
<td>每次存取更新 timestamp；換頁找最小 timestamp</td>
<td style="text-align:right">O(1)</td>
<td style="text-align:right">O(n)</td>
<td>換頁要線性掃描，太慢</td>
</tr>
<tr>
<td>Stack（雙向鏈結串列）+ Hash</td>
<td>存取就把頁移到最上（MRU）；換頁拿最下（LRU）</td>
<td style="text-align:right">O(1)*</td>
<td style="text-align:right">O(1)</td>
<td><strong>每次存取都要維護資料結構</strong>，overhead 大</td>
</tr>
</tbody>
</table>
<p>Stack algorithm 性質</p>
<table>
<thead>
<tr>
<th>名詞</th>
<th>定義/性質</th>
<th>重要結論</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stack algorithm</td>
<td>Pages(n) ⊆ Pages(n+1)（n frames 的集合是 n+1 的子集合）</td>
<td><strong>不會有 Belady anomaly</strong></td>
<td>OPT、LRU</td>
</tr>
</tbody>
</table>
<p>LRU Approximation</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用哪些 bits</th>
<th>核心概念</th>
<th>優點</th>
<th>缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reference bit 機制</td>
<td>R</td>
<td>硬體存取自動設 R=1；OS 定期清 0</td>
<td>幾乎無 per-access 軟體成本</td>
<td>只有「最近/不最近」粗資訊</td>
</tr>
<tr>
<td>Additional-reference-bits</td>
<td>多個 R（history）</td>
<td>用多bit記錄一段時間存取歷史</td>
<td>更像 LRU</td>
<td>bits越多成本越高</td>
</tr>
<tr>
<td>Second-chance / Clock</td>
<td>R</td>
<td>FIFO + second chance（R=1 先放過一次）</td>
<td>最常見、平衡好</td>
<td>近似，不是精準 LRU</td>
</tr>
<tr>
<td>Enhanced Clock</td>
<td>R + dirty</td>
<td>先踢 (R=0,dirty=0)</td>
<td>少寫回、I/O佳</td>
<td>複雜些</td>
</tr>
</tbody>
</table>
<hr>
<h1>Allocation of Frames</h1>
<p>OS 在做 frame allocation（分配實體記憶體 frames）時要決定： <strong>每個 process 應該拿到多少 frames？</strong></p>
<p>重要限制：每個 process 都 <strong>「至少」需要一個最小 frames 數</strong></p>
<p>如果 frames 太少會怎樣？</p>
<ul>
<li>可能 Page A , Page B 互相把對方推擠掉</li>
<li>同一條指令執行過程就無限 fault</li>
</ul>
<p>解法 :</p>
<ul>
<li>**分配「足夠 frames」**給每個 process。</li>
</ul>
<h2 id="Frame-Allocation-Strategies">Frame Allocation Strategies</h2>
<p>把有限的 frames 分配到各 processes</p>
<p>方法 :</p>
<ol>
<li>Fixed allocation schemes（固定分配）
<ul>
<li>Equal allocation（平均分）</li>
<li>Proportional allocation（按大小比例分）</li>
</ul>
</li>
<li>Priority allocation（按優先權分）
<ul>
<li>不看大小，改看 priority（重要的 process 給更多）
<ul>
<li>Priority-based proportional allocation：分配時就把 priority 納入比例</li>
<li>Priority-based replacement：高 priority process page fault 時，允許它 <strong>「從低 priority process 那裡拿 frame」</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="可以怎麼選-Local-vs-Global-Replacement">可以怎麼選 ? Local vs Global Replacement</h2>
<p>Local replacement（只從自己 frames 挑）</p>
<ul>
<li>
<p>victim 只能是 **「這個 process 已分到的 frames」**之一</p>
</li>
<li>
<p>優點： 可預測、隔離（別人不會搶你的 frame）</p>
</li>
<li>
<p>缺點： 不靈活、可能效率差（有的 process 明明很需要，但不能借別人的）</p>
</li>
</ul>
<p>Global replacement（可以從全系統 frames 挑）<strong>(常用)</strong></p>
<ul>
<li>victim 可以從 **「任何 process 的 frames」**挑</li>
<li>優點： <strong>效率好</strong>、彈性高、吞吐量高</li>
<li>缺點：
<ul>
<li>不可預測：你可能突然被別人搶 frame</li>
<li>thrashing 可能擴散：某個 process 狂 fault，可能把別人也搞到 fault 增加</li>
</ul>
</li>
</ul>
<hr>
<h1>Thrashing</h1>
<p>Thrashing = 花的時間在Paging比執行時間多</p>
<p>可能導致原因 :</p>
<ul>
<li>Process <strong>frames 不夠</strong> → 無法同時把「正在用的那群 pages」留在 RAM。</li>
<li>也就是 <strong>無法容納 working set</strong> → 造成幾乎每次存取都 page fault。</li>
</ul>
<p>Characteristics :</p>
<ul>
<li><strong>Excessive paging activity</strong>：換頁爆量</li>
<li><strong>Performance collapse</strong>：效能崩壞</li>
</ul>
<blockquote>
<p>Thrashing = 換頁比做事還多；根因是 frames 不足以裝下 working set，會造成效能崩盤。</p>
</blockquote>
<h2 id="Thrashing-The-Performance-Collapse-Cycle">Thrashing: The Performance Collapse Cycle</h2>
<p>特別容易出現在 <strong>Global page replacement policy</strong>（全域替換）下</p>
<p>Progression to Thrashing :</p>
<ol>
<li>frames 足夠 → 正常執行</li>
<li>frames 減少 → page faults 增加</li>
<li>低於門檻 → 幾乎每次存取都 fault</li>
<li>thrashing → process 幾乎沒進度（no forward progress）</li>
</ol>
<p>System-wide Impact（會「傳染」）:</p>
<ul>
<li>一個 thrashing process 可能引發全系統 thrashing：
<ul>
<li>大家都在等 I/O → CPU usage 看起來很低</li>
<li>OS 可能誤判「CPU 很閒」→ <strong>admit 更多 processes</strong></li>
<li>processes 更多 → frames 更少 → faults 更高 → <strong>cascade effect</strong></li>
</ul>
</li>
</ul>
<p>Thrashing Spiral（惡性循環 8 步）</p>
<ol>
<li>Process 開始 page fault</li>
<li>I/O queue 增長（等待換頁）</li>
<li>CPU utilization 下降（process <strong>blocked on I/O</strong>）</li>
<li>OS 誤判：<strong>CPU 低</strong> → <strong>需要更多 process</strong></li>
<li>Admit 更多 process（multiprogramming degree ↑）</li>
<li>frames 競爭加劇（新 process 搶 frames）</li>
<li>faults 連鎖上升（大家 fault 更頻繁）</li>
<li>系統崩潰：CPU utilization → 接近 0</li>
</ol>
<h2 id="Prevention-Strategies">Prevention Strategies</h2>
<ul>
<li>必須讓每個 process 有足夠 frames：
<ul>
<li><strong>Working-Set Model</strong></li>
<li><strong>Page-Fault Frequency (PFF)</strong></li>
</ul>
</li>
</ul>
<h2 id="Working-Set-Model">Working-Set Model</h2>
<blockquote>
<p>Working set 用來近似真正 locality</p>
</blockquote>
<p>Locality of Reference（區域性）:</p>
<ul>
<li>程式會以「階段（phases）」方式使用<strong>少量 pages</strong>：
<ul>
<li>function 呼叫 → code locality 改變</li>
<li>data iteration → data locality 改變</li>
</ul>
</li>
</ul>
<p>Model Components（定義）:</p>
<ul>
<li>
<p><strong>Δ（Delta）</strong>：視窗大小（時間或 references 數量）</p>
</li>
<li>
<p><strong>WS(t, Δ)</strong>：在視窗區間 <strong>[t − Δ, t]</strong> 內被參考過的 pages 集合</p>
</li>
<li>
<p><strong>|WS|</strong>：working set size（集合大小）≈ process 需要的 frames 數</p>
</li>
<li>
<p><strong>Δ 的選擇很關鍵</strong>：</p>
<ul>
<li>Δ 太小 → 低估需求</li>
<li>Δ 太大 → 高估需求（把過去用過但已不需要的也算進來）</li>
</ul>
</li>
</ul>
<p>運作 :</p>
<ul>
<li>Ex1 : 2 6 1 5 7 7 7 7 5 1
<ul>
<li>WS(t1) = {1,2,5,6,7}</li>
</ul>
</li>
<li>Ex2 : 3 4 4 3 4 3 4 4 4 4
<ul>
<li>WS(t2) = {3,4}</li>
</ul>
</li>
</ul>
<blockquote>
<p>程式不同時間進入不同 phase → 使用的 pages 群組會改變（locality shift）。</p>
</blockquote>
<h2 id="Working-Set-Model-for-Thrashing-Prevention">Working-Set Model for Thrashing Prevention :</h2>
<p>Core Strategy（核心量）:</p>
<ul>
<li><strong>WSSᵢ</strong>：process i 的 working set size（需要 frames）</li>
<li><strong>D = Σ WSSᵢ</strong>：全系統總 frames 需求（total demand）</li>
<li><strong>m</strong>：可用實體 frames 總量</li>
</ul>
<p>Decision Framework（決策）</p>
<ul>
<li><strong>D &gt; m</strong>：需求 &gt; 供給 → 系統會 thrash<br>
→ 必須 <strong>suspend / swap out</strong> 一些 process（降低 multiprogramming degree）</li>
<li><strong>D ≈ m</strong>：接近最佳狀態（高利用、低 thrash）</li>
<li><strong>D &lt;&lt; m</strong>：記憶體閒置 → 可 admit 新 process 或喚回 suspended process</li>
</ul>
<p>OS Implementation</p>
<ul>
<li>持續追蹤每個 process 的 WSS</li>
<li>分配 frames 保證 WSS</li>
<li>透過 suspend / admit 調整多工度</li>
</ul>
<h2 id="Working-Set-Model：優缺點">Working-Set Model：優缺點</h2>
<p>Advantages（優點）:</p>
<ol>
<li>避免 thrashing（確保足夠 frames）</li>
<li>最大化 multiprogramming（不 thrash 前提下跑最多）</li>
<li>最佳化 CPU utilization（平衡記憶體壓力與吞吐）</li>
<li>自適應（working set 改變可調整）</li>
</ol>
<p>Disadvantages（缺點）:</p>
<ol>
<li><strong>高 overhead</strong>：追蹤 page references 很貴</li>
<li>實作複雜：每個 process 維護滑動視窗</li>
<li>Δ 不好決定（估計誤差風險）</li>
<li>需維護 reference history（儲存成本）</li>
</ol>
<p>Practical Approximations（實務近似）</p>
<ul>
<li>參考位元（reference bits）+ 週期掃描</li>
<li>用 page fault frequency 估 WSS</li>
<li>抽樣（sampling）取代全面監控</li>
</ul>
<h2 id="Page-Fault-Frequency-PFF-Scheme（直接盯-fault-rate）">Page-Fault Frequency (PFF) Scheme（直接盯 fault rate）</h2>
<p>核心概念 :</p>
<ul>
<li>直接監控每個 process 的 <strong>page-fault rate</strong>，</li>
<li>透過動態調整 frames 來避免 thrashing。</li>
</ul>
<p>Control Parameters（門檻）</p>
<ul>
<li><strong>PFFmax</strong>：最大可接受 fault rate（太高代表快 thrash）</li>
<li><strong>PFFmin</strong>：太低代表 frames 過多（可回收）</li>
<li>目標區間：<strong>PFFmin ≤ fault rate ≤ PFFmax</strong></li>
</ul>
<p>Control Algorithm（控制規則）</p>
<ul>
<li>若 <strong>PFF &gt; PFFmax</strong>：
<ul>
<li>process 需要更多 frames → <strong>allocate frames</strong></li>
<li>若沒有 free frames → <strong>suspend process</strong></li>
</ul>
</li>
<li>若 <strong>PFF &lt; PFFmin</strong>：
<ul>
<li>process frames 過多 → <strong>reclaim frames</strong> 加回 free pool</li>
</ul>
</li>
<li>若在區間內：
<ul>
<li><strong>no action</strong></li>
</ul>
</li>
</ul>
<h2 id="PFF-圖（fault-rate-vs-number-of-frames）">PFF 圖（fault rate vs number of frames）</h2>
<p>直覺 :</p>
<ul>
<li>frames ↑ → fault rate ↓（通常是下降曲線）</li>
<li>高於 upper bound（PFFmax）→ 增加 frames</li>
<li>低於 lower bound（PFFmin）→ 減少 frames</li>
</ul>
<h2 id="Working-Sets-Page-Fault-Rates-Dynamic-Relationship（WS-與-fault-rate-的動態關係）">Working Sets &amp; Page Fault Rates: Dynamic Relationship（WS 與 fault rate 的動態關係）</h2>
<p>Memory locality 的時間變化 :</p>
<ul>
<li><strong>Stable working set</strong> → fault rate 低且穩定</li>
<li><strong>Locality shift begins</strong>（進入新 phase）→ 需要載入新 pages → fault rate 上升</li>
<li><strong>Fault rate spikes</strong> → 逐步建立新的 working set</li>
<li><strong>Peak fault rate</strong>（最大 churn）</li>
<li><strong>New WS established</strong> → fault rate 下降並穩定在新的 baseline</li>
</ul>
<hr>
<blockquote>
<p>只能說現在 1:40 作者我要陣亡了</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://YowDesert.github.io">YowDesert</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://yowdesert.github.io/posts/8075d89.html">https://yowdesert.github.io/posts/8075d89.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://YowDesert.github.io" target="_blank">YD's 資訊學習筆記</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/">作業系統</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="ads-wrap"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5975504062599634" crossorigin="anonymous"></script> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5975504062599634" data-ad-slot="7226702911" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/cf6482ff.html" title="(作業系統) File System"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">(作業系統) File System</div></div><div class="info-2"><div class="info-item-1">快速摘要   檔案與目錄是什麼抽象？OS 提供哪些操作？   檔案本質上是「一串位元組（bytes）」的邏輯視圖   目錄的工作是把 name → 檔案的 metadata（inode/FCB） 對起來   常見操作：create/open/read/write/seek/close/delete/truncate，以及目錄的 search/rename/traverse 等     檔案系統內部要維護哪些關鍵資料結構？（磁碟上 vs 記憶體中）   磁碟上會有：boot block、volume control（superblock 概念）、每個檔案的 inode/FCB、目錄內容   記憶體中會有：mount table、directory cache、system-wide open-file table、per-process fd table   目的都是讓「路徑解析、開檔、讀寫」變快，同時維持一致性     檔案資料實際要怎麼放到磁碟 blocks？空閒空間怎麼管理？（本章超級考點）   配置方法重點比較：   Contiguous（快但外部碎裂、成長不易）   Li...</div></div></div></a><a class="pagination-related" href="/posts/6575bc75.html" title="(作業系統) Main Memory Management"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">(作業系統) Main Memory Management</div></div><div class="info-2"><div class="info-item-1"> 本章內容 : 作業系統如何管理「主記憶體（RAM）」：讓多個行程安全、有效率地共用有限的記憶體。  前導  為什麼「主記憶體管理」很重要？   CPU 只能直接存取主記憶體   記憶體是：  昂貴 有限    多個行程要一起用  OS 必須解決三個核心問題： 誰用哪一塊記憶體？ 怎麼防止程式亂讀／亂寫別人的記憶體？ 怎麼讓記憶體使用率最高？       摘要 BackGround  CPU 能直接存取的很少，只有Main Memory和 Registers而已 Disk 上的程式，只是「檔案」而已，要被Loader載入memory才會變成Process 把多個程式放進 RAM → 多程式（multiprogramming）: 改善CPU使用率以及加快反應時間 process 會移動在Disk和memory之間  Memory Management Issues  How to refer to memory in a program? → Address binding How to load a program into memory? → static/dynamic lo...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/67c68839.html" title="(作業系統) Deadlock Definition, Avoidance and Resolution"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-13</div><div class="info-item-2">(作業系統) Deadlock Definition, Avoidance and Resolution</div></div><div class="info-2"><div class="info-item-1">Deadlock基本概念 1. Deadlock 是什麼？ Deadlock 指的是：  一組 processes 彼此等待對方所持有的資源，導致所有 process 都無法繼續執行。  Deadlock 的特徵  每個 process：  已持有至少一個資源 同時等待另一個 process 持有的資源   結果：大家互等，系統停住   2. Deadlock 範例 Example 1：兩個 processes、兩個資源  P1 持有 R1，等待 R2 P2 持有 R2，等待 R1 → 互相等待，發生 deadlock  Example 2：Semaphore A 與 B 12P1: wait(A); wait(B); ...; signal(B); signal(A);P2: wait(B); wait(A); ...; signal(A); signal(B);  若 P1 先拿到 A、P2 先拿到 B 下一步彼此都在等對方 → deadlock   Deadlock 的四個必要條件 Deadlock 當且僅當下列四個條件同時成立：  Mutual Exclusion（互斥）...</div></div></div></a><a class="pagination-related" href="/posts/90aa57da.html" title="(作業系統) Process and Concurrency - Synchronization Concepts"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="info-item-2">(作業系統) Process and Concurrency - Synchronization Concepts</div></div><div class="info-2"><div class="info-item-1">簡短說明：  主題：Synchronization Concepts 本章重點：  什麼情況下會發生 Race Condition？ 作業系統必須滿足哪些條件，才能正確管理共享資源？ 有哪些同步機制（Synchronization Mechanisms）可以保證程式正確性？      Background 問題與解決   The Problem :  Concurrent access to shared data may result in data inconsistency Outcome depends on the order of execution(race condition)    The Solution :  Ensure orderly execution Synchronization : 協調資源的分享與存取 保證 Data Integrity 和 Correctness    Consumer and Producer Problem :   變數意義 :  in：下一個要放入的位置（next free position） out：下一個要取出的項目...</div></div></div></a><a class="pagination-related" href="/posts/6575bc75.html" title="(作業系統) Main Memory Management"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-19</div><div class="info-item-2">(作業系統) Main Memory Management</div></div><div class="info-2"><div class="info-item-1"> 本章內容 : 作業系統如何管理「主記憶體（RAM）」：讓多個行程安全、有效率地共用有限的記憶體。  前導  為什麼「主記憶體管理」很重要？   CPU 只能直接存取主記憶體   記憶體是：  昂貴 有限    多個行程要一起用  OS 必須解決三個核心問題： 誰用哪一塊記憶體？ 怎麼防止程式亂讀／亂寫別人的記憶體？ 怎麼讓記憶體使用率最高？       摘要 BackGround  CPU 能直接存取的很少，只有Main Memory和 Registers而已 Disk 上的程式，只是「檔案」而已，要被Loader載入memory才會變成Process 把多個程式放進 RAM → 多程式（multiprogramming）: 改善CPU使用率以及加快反應時間 process 會移動在Disk和memory之間  Memory Management Issues  How to refer to memory in a program? → Address binding How to load a program into memory? → static/dynamic lo...</div></div></div></a><a class="pagination-related" href="/posts/cf6482ff.html" title="(作業系統) File System"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-21</div><div class="info-item-2">(作業系統) File System</div></div><div class="info-2"><div class="info-item-1">快速摘要   檔案與目錄是什麼抽象？OS 提供哪些操作？   檔案本質上是「一串位元組（bytes）」的邏輯視圖   目錄的工作是把 name → 檔案的 metadata（inode/FCB） 對起來   常見操作：create/open/read/write/seek/close/delete/truncate，以及目錄的 search/rename/traverse 等     檔案系統內部要維護哪些關鍵資料結構？（磁碟上 vs 記憶體中）   磁碟上會有：boot block、volume control（superblock 概念）、每個檔案的 inode/FCB、目錄內容   記憶體中會有：mount table、directory cache、system-wide open-file table、per-process fd table   目的都是讓「路徑解析、開檔、讀寫」變快，同時維持一致性     檔案資料實際要怎麼放到磁碟 blocks？空閒空間怎麼管理？（本章超級考點）   配置方法重點比較：   Contiguous（快但外部碎裂、成長不易）   Li...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">YowDesert</div><div class="author-info-description">這是YowDesert的部落格，記錄學習資訊工程領域的過程和心得，並以簡單白話的方式呈現，一起和我踏入資訊世界吧，有興趣的話歡迎Follow我歐。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yowdesert"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yowdesert" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:csaidesert@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">快速導覽</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">BackGround</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Use-VM"><span class="toc-number">2.1.</span> <span class="toc-text">Why Use VM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VM-%E8%A7%A3%E6%B1%BA-Memory-4-Problem"><span class="toc-number">2.2.</span> <span class="toc-text">VM 解決 Memory 4 Problem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VM-Benefits"><span class="toc-number">2.3.</span> <span class="toc-text">VM Benefits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementation"><span class="toc-number">2.4.</span> <span class="toc-text">Implementation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Demand Paging</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A4%8E%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">基礎概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pure-Demand-Paging"><span class="toc-number">3.2.</span> <span class="toc-text">Pure Demand Paging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pager-v-s-Swapper"><span class="toc-number">3.3.</span> <span class="toc-text">Pager v.s Swapper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Fault-Handling"><span class="toc-number">3.4.</span> <span class="toc-text">Page Fault Handling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Replacement"><span class="toc-number">3.5.</span> <span class="toc-text">Page Replacement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demand-Paging-Performance"><span class="toc-number">3.6.</span> <span class="toc-text">Demand Paging Performance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Demand-Paging-Works"><span class="toc-number">3.7.</span> <span class="toc-text">Why Demand Paging Works</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#page-fault-%E7%82%BA%E4%BB%80%E9%BA%BC%E9%80%99%E9%BA%BC%E6%85%A2%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">page fault 為什麼這麼慢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Process Creation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Page Replacement</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Replacement-Algorithms"><span class="toc-number">5.1.</span> <span class="toc-text">Page Replacement Algorithms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FIFO"><span class="toc-number">5.2.</span> <span class="toc-text">FIFO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FIFO-%E7%9A%84-Belady%E2%80%99s-Anomaly"><span class="toc-number">5.3.</span> <span class="toc-text">FIFO 的 Belady’s Anomaly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OPT-MIN-Belady%E2%80%99s-Algorithm"><span class="toc-number">5.4.</span> <span class="toc-text">OPT &#x2F; MIN &#x2F; Belady’s Algorithm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU%EF%BC%88Least-Recently-Used%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">LRU（Least Recently Used）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack-Algorithms"><span class="toc-number">5.6.</span> <span class="toc-text">Stack Algorithms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU-Approximation%EF%BC%9AReference-Bit"><span class="toc-number">5.7.</span> <span class="toc-text">LRU Approximation：Reference Bit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU-Approximation-%E7%9A%84%E4%B8%89%E5%80%8B%E6%BC%94%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.</span> <span class="toc-text">LRU Approximation 的三個演算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Frequency-Based-%E4%B8%8D%E5%B8%B8%E7%94%A8"><span class="toc-number">5.9.</span> <span class="toc-text">Frequency-Based (不常用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B8%BD%E7%B5%90%E8%A1%A8%E6%A0%BC"><span class="toc-number">5.10.</span> <span class="toc-text">總結表格</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Allocation of Frames</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Frame-Allocation-Strategies"><span class="toc-number">6.1.</span> <span class="toc-text">Frame Allocation Strategies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E6%80%8E%E9%BA%BC%E9%81%B8-Local-vs-Global-Replacement"><span class="toc-number">6.2.</span> <span class="toc-text">可以怎麼選 ? Local vs Global Replacement</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Thrashing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thrashing-The-Performance-Collapse-Cycle"><span class="toc-number">7.1.</span> <span class="toc-text">Thrashing: The Performance Collapse Cycle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prevention-Strategies"><span class="toc-number">7.2.</span> <span class="toc-text">Prevention Strategies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Working-Set-Model"><span class="toc-number">7.3.</span> <span class="toc-text">Working-Set Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Working-Set-Model-for-Thrashing-Prevention"><span class="toc-number">7.4.</span> <span class="toc-text">Working-Set Model for Thrashing Prevention :</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Working-Set-Model%EF%BC%9A%E5%84%AA%E7%BC%BA%E9%BB%9E"><span class="toc-number">7.5.</span> <span class="toc-text">Working-Set Model：優缺點</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Fault-Frequency-PFF-Scheme%EF%BC%88%E7%9B%B4%E6%8E%A5%E7%9B%AF-fault-rate%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">Page-Fault Frequency (PFF) Scheme（直接盯 fault rate）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PFF-%E5%9C%96%EF%BC%88fault-rate-vs-number-of-frames%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">PFF 圖（fault rate vs number of frames）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Working-Sets-Page-Fault-Rates-Dynamic-Relationship%EF%BC%88WS-%E8%88%87-fault-rate-%E7%9A%84%E5%8B%95%E6%85%8B%E9%97%9C%E4%BF%82%EF%BC%89"><span class="toc-number">7.8.</span> <span class="toc-text">Working Sets &amp; Page Fault Rates: Dynamic Relationship（WS 與 fault rate 的動態關係）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2afc752c.html" title="[日文] 日文學習-初級1-文法">[日文] 日文學習-初級1-文法</a><time datetime="2026-01-05T04:00:00.000Z" title="發表於 2026-01-05 12:00:00">2026-01-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/c7d4007f.html" title="[日文] 日文學習-初級2-單字">[日文] 日文學習-初級2-單字</a><time datetime="2026-01-05T04:00:00.000Z" title="發表於 2026-01-05 12:00:00">2026-01-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/918b2cda.html" title="[日文] 日文學習-初級1-單字">[日文] 日文學習-初級1-單字</a><time datetime="2025-12-31T08:45:00.000Z" title="發表於 2025-12-31 16:45:00">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/a47372cf.html" title="[日文] 日文學習-初級2-文法">[日文] 日文學習-初級2-文法</a><time datetime="2025-12-31T08:45:00.000Z" title="發表於 2025-12-31 16:45:00">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/cf6482ff.html" title="(作業系統) File System">(作業系統) File System</a><time datetime="2025-12-21T05:15:00.000Z" title="發表於 2025-12-21 13:15:00">2025-12-21</time></div></div></div></div><div class="card-widget ads-wrap"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5975504062599634" crossorigin="anonymous"></script> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5975504062599634" data-ad-slot="9206833147" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></div></div></div></main><footer id="footer" style="background-image: url(/img/nav_Picture.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By YowDesert</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主題 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="/"></script></div></body></html>