<!DOCTYPE html><html lang="zh-TW"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>(作業系統) Main Memory Management | YD's 資訊學習筆記</title><meta name="author" content="YowDesert"><meta name="copyright" content="YowDesert"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本章內容 : 作業系統如何管理「主記憶體（RAM）」：讓多個行程安全、有效率地共用有限的記憶體。  前導  為什麼「主記憶體管理」很重要？   CPU 只能直接存取主記憶體   記憶體是：  昂貴 有限    多個行程要一起用  OS 必須解決三個核心問題： 誰用哪一塊記憶體？ 怎麼防止程式亂讀／亂寫別人的記憶體？ 怎麼讓記憶體使用率最高？       摘要 BackGround  CPU 能直">
<meta property="og:type" content="article">
<meta property="og:title" content="(作業系統) Main Memory Management">
<meta property="og:url" content="https://yowdesert.github.io/posts/6575bc75.html">
<meta property="og:site_name" content="YD&#39;s 資訊學習筆記">
<meta property="og:description" content="本章內容 : 作業系統如何管理「主記憶體（RAM）」：讓多個行程安全、有效率地共用有限的記憶體。  前導  為什麼「主記憶體管理」很重要？   CPU 只能直接存取主記憶體   記憶體是：  昂貴 有限    多個行程要一起用  OS 必須解決三個核心問題： 誰用哪一塊記憶體？ 怎麼防止程式亂讀／亂寫別人的記憶體？ 怎麼讓記憶體使用率最高？       摘要 BackGround  CPU 能直">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://yowdesert.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-12-19T06:15:00.000Z">
<meta property="article:modified_time" content="2025-12-19T16:34:39.735Z">
<meta property="article:author" content="YowDesert">
<meta property="article:tag" content="作業系統">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yowdesert.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "(作業系統) Main Memory Management",
  "url": "https://yowdesert.github.io/posts/6575bc75.html",
  "image": "https://yowdesert.github.io/img/butterfly-icon.png",
  "datePublished": "2025-12-19T06:15:00.000Z",
  "dateModified": "2025-12-19T16:34:39.735Z",
  "author": [
    {
      "@type": "Person",
      "name": "YowDesert",
      "url": "https://YowDesert.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yowdesert.github.io/posts/6575bc75.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="google5c543dcf16a66e3c.html"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-5975504062599634',
  enable_page_level_ads: 'true'
});</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '複製成功',
    error: '複製失敗',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切換為繁體中文","cht_to_chs":"已切換為簡體中文","day_to_night":"已切換為深色模式","night_to_day":"已切換為淺色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '載入更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '(作業系統) Main Memory Management',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="YD's 資訊學習筆記" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/backgroundPic.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/nav_Picture.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/Top.png" alt="Logo"><span class="site-name">YD's 資訊學習筆記</span></a><a class="nav-page-title" href="/"><span class="site-name">(作業系統) Main Memory Management</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首頁</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">(作業系統) Main Memory Management</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2025-12-19T06:15:00.000Z" title="發表於 2025-12-19 14:15:00">2025-12-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-12-19T16:34:39.735Z" title="更新於 2025-12-20 00:34:39">2025-12-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/">作業系統</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/Memory-Management/">Memory Management</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">總字數:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時間:</span><span>27分鐘</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>本章內容 : 作業系統如何管理「主記憶體（RAM）」：讓多個行程安全、有效率地共用有限的記憶體。</p>
</blockquote>
<h1>前導</h1>
<ul>
<li>為什麼「主記憶體管理」很重要？
<ul>
<li>
<p>CPU 只能直接存取主記憶體</p>
</li>
<li>
<p>記憶體是：</p>
<ul>
<li>昂貴</li>
<li>有限</li>
</ul>
</li>
<li>
<p>多個行程要一起用</p>
<ul>
<li>OS 必須解決三個核心問題：</li>
<li>誰用哪一塊記憶體？</li>
<li>怎麼防止程式亂讀／亂寫別人的記憶體？</li>
<li>怎麼讓記憶體使用率最高？</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1>摘要</h1>
<h2 id="BackGround">BackGround</h2>
<ul>
<li>CPU 能直接存取的很少，只有<strong>Main Memory</strong>和 <strong>Registers</strong>而已</li>
<li>Disk 上的程式，只是「檔案」而已，<strong>要被Loader載入memory才會變成Process</strong></li>
<li>把多個程式放進 RAM → 多程式（multiprogramming）: <strong>改善CPU使用率</strong>以及<strong>加快反應時間</strong></li>
<li>process 會移動在<strong>Disk</strong>和<strong>memory</strong>之間</li>
</ul>
<h2 id="Memory-Management-Issues">Memory Management Issues</h2>
<ul>
<li>How to refer to memory in a program? → Address binding</li>
<li>How to load a program into memory? → static/dynamic loading &amp; linking</li>
<li>How to move a program between memory and disk? → Swapping</li>
<li>How to allocate memory? → Paging, Segmentation</li>
</ul>
<h2 id="Multistep-Processing">Multistep Processing</h2>
<ol>
<li>Source program（原始碼）</li>
<li>Compiler/Assembler → Object module（目標檔 .o）</li>
<li>Linkage editor（linker）
<ul>
<li>把你的 object 檔 + 其他 object 檔 + library 接起來</li>
</ul>
</li>
<li>產生 Load module（可載入檔 / executable）</li>
<li>Loader
<ul>
<li>OS/loader 把 load module 放到 RAM，形成 in-memory binary image（記憶體中的程式映像）</li>
</ul>
</li>
<li>Dynamic linking（動態連結）
<ul>
<li>有些 library 不會在 linker 時就塞進去<br>
會在「執行時」才載入/連結（例如共享函式庫 .so / .dll）</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>因為「位址到底何時決定」有三種：</p>
<ul>
<li>編譯期決定（compile time）</li>
<li>載入期決定（load time）</li>
<li>執行期決定（execution time）</li>
</ul>
</li>
</ul>
<hr>
<h1>Address Binding</h1>
<h2 id="Compile-Time（編譯期綁定）">Compile Time（編譯期綁定）</h2>
<ul>
<li>程式一開始寫的是symbolic address(符號位址)
<blockquote>
<p>symbolic address : 在寫程式、編譯之前或剛編譯完，程式裡出現的位址通常是：變數名稱、函式名稱、label、相對位置</p>
</blockquote>
</li>
<li>在編譯期就決定他在Memory的<strong>絕對位址</strong>，編譯器就會產生<strong>絕對位址</strong></li>
</ul>
<p>✅ 結論</p>
<ul>
<li>優點：簡單、快（不用 relocation）</li>
<li>缺點：起始位置一改就完蛋 → 必須<strong>重新編譯</strong>（recompile）</li>
<li>例子：老系統 MS-DOS .COM 程式（固定載入位置）</li>
</ul>
<h2 id="Load-Time（載入期綁定）">Load Time（載入期綁定）</h2>
<ul>
<li>編譯器不產生寫死的絕對位址，而是產生 relocatable code（可重定位碼）</li>
<li>程式碼裡用「相對於起點」的方式表示位址（Ex. BS + 0x18）</li>
</ul>
<p>✅ 結論（考點）</p>
<ul>
<li>優點：同一份 executable 可以載入到不同位置</li>
<li>缺點：如果起點改了 → 不用重編譯，但要<strong>重新載入</strong>（reload）</li>
<li>這需要 loader 做 relocation（重定位）（通常靠 relocation table）</li>
</ul>
<h2 id="Execution-Time（執行期綁定）">Execution Time（執行期綁定）</h2>
<blockquote>
<p>現代 OS 幾乎都用這個。</p>
</blockquote>
<ul>
<li>程式看到的是 <strong>logical address</strong>(i.e., virtual address)
<ul>
<li>例如它可能以為 data 在 0x18</li>
</ul>
</li>
<li>真正的 physical address（例如 0x2018）由<strong>special hardware</strong>(ex.the MMU) 在每次記憶體存取時「<strong>即時轉換</strong>」
<ul>
<li>MMU : CPU 發出 virtual address → MMU 翻成 physical address</li>
</ul>
</li>
</ul>
<p>✅ 結論（超常考）</p>
<ul>
<li>優點：
<ul>
<li>程式可以在執行途中被搬家（支援 swapping / relocation / virtual memory）</li>
<li>每個 process 都可以有「<strong>自己的位址空間</strong>」（安全、隔離）</li>
</ul>
</li>
<li>缺點：
<ul>
<li>需要硬體支援（MMU），會有轉換成本（靠 TLB 加速）</li>
</ul>
</li>
</ul>
<h2 id="Memory-Management-Unit-MMU">Memory-Management Unit(MMU)</h2>
<ul>
<li>MMU 是 CPU 裡的硬體元件，在程式執行時把 <strong>Virtual/Logical Address（虛擬/邏輯位址）→ Physical Address（實體位址）</strong>。</li>
<li>Translation mechanism : Physical Address = Base Register (relocation register) + Logical Address
<ul>
<li>例子 :
<ul>
<li>CPU 產生 Logical Address = <code>346</code></li>
<li>relocation register 位址 <code>12000</code></li>
<li>Physical Address = Base + Logical = <code>12000</code> + <code>346</code> = <code>12346</code></li>
<li>最後去 Memory 存取 <code>12346</code></li>
</ul>
</li>
</ul>
</li>
<li>✅優點：
<ul>
<li>Memory protection（保護）
<ul>
<li>每個 process 只能在自己的範圍內活動。</li>
</ul>
</li>
<li>Dynamic relocation（動態搬家）
<ul>
<li>base 改掉，整個程式的位址就「等效搬家」，不用重編譯。</li>
</ul>
</li>
<li>支援 virtual memory</li>
</ul>
</li>
</ul>
<h2 id="Logical-v-s-Physical-Address">Logical v.s. Physical Address</h2>
<blockquote>
<p>User program 只用 logical address，不需要知道 physical memory 在哪。</p>
</blockquote>
<ul>
<li>
<p>Logical Address（= Virtual Address）</p>
<ul>
<li><strong>CPU 在執行時產生的位址</strong></li>
<li>使用者程式看得到、操作的位址空間</li>
</ul>
</li>
<li>
<p>Physical Address</p>
<ul>
<li><strong>RAM 裡真正的位址</strong></li>
<li>最終由記憶體硬體去存取</li>
</ul>
</li>
<li>
<p>跟 Address Binding 的關係</p>
<table>
<thead>
<tr>
<th>項目</th>
<th>Compile-time / Load-time Binding</th>
<th>Execution-time Binding</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>位址綁定時機</strong></td>
<td><strong>執行前</strong>（compile 或 load 時）</td>
<td><strong>執行中</strong>（run time）</td>
</tr>
<tr>
<td><strong>位址是否先定死</strong></td>
<td>✅ 是，已定成實體位址</td>
<td>❌ 否，執行時才轉換</td>
</tr>
<tr>
<td><strong>Logical address</strong></td>
<td>= Physical address</td>
<td>≠ Physical address</td>
</tr>
<tr>
<td><strong>是否需要 MMU</strong></td>
<td>❌ 不需要</td>
<td>✅ 需要</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h1>Load Program  into Memory → static/dynamic loading &amp; linking</h1>
<h2 id="Dynamic-Loading">Dynamic Loading</h2>
<blockquote>
<p>不需要整個 Program 載入 Memory → 用到再載入就好</p>
</blockquote>
<ul>
<li>
<p>只需載入<strong>被呼叫</strong>的程式碼進記憶體就好</p>
</li>
<li>
<p>沒被執行的就放在硬碟就好了</p>
</li>
<li>
<p>✅優點： <strong>改善Memory utilization</strong></p>
</li>
<li>
<p>實作 : 其實他理論上來說<strong>可以不用OS提供新的支援</strong>，可以用使用者層的方法做到</p>
</li>
</ul>
<h2 id="Static-Linking">Static Linking</h2>
<ul>
<li><strong>在link time時</strong>，將有用到的Libraries打包進可執行檔 → <strong>單一包含所有需要程式的執行檔</strong></li>
<li>特性 :
<ul>
<li>缺點：記憶體浪費（duplicate library code）: 多個程式各自帶一份 libc → RAM 會出現<strong>多份重複</strong></li>
</ul>
</li>
</ul>
<p>✅優點：</p>
<ul>
<li>執行快
<ul>
<li>不用在 runtime 做符號解析（resolve），呼叫可直接跳</li>
</ul>
</li>
<li>自給自足
<ul>
<li>不怕機器上缺 library（部署比較直覺）</li>
</ul>
</li>
</ul>
<p><strong>Static Linking with Dynamic Loading</strong></p>
<ul>
<li>核心/常用部分：靜態連結</li>
<li>某些模組：用 dynamic loading 按需載入</li>
<li><strong>但重複碼問題仍在</strong>：因為靜態連結的 library 每個 process 仍各有一份。</li>
</ul>
<p><strong>Trade-off Analysis</strong></p>
<table>
<thead>
<tr>
<th>面向</th>
<th>重點</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Memory usage</strong></td>
<td>❌ 浪費（library <strong>無法共用</strong>，每個 process 一份）</td>
</tr>
<tr>
<td><strong>Execution speed</strong></td>
<td>✅ 快（<strong>direct calls</strong>）</td>
</tr>
<tr>
<td><strong>Deployment</strong></td>
<td>✅ 簡單（<strong>無相依 library</strong>）</td>
</tr>
<tr>
<td><strong>Updates</strong></td>
<td>❌ 不彈性（library 更新 → <strong>需重新編譯/發佈</strong>）</td>
</tr>
</tbody>
</table>
<h2 id="Dynamic-Linking">Dynamic Linking</h2>
<blockquote>
<p>Dynamic linking = 第一次呼叫要辦手續，之後就走快速通關</p>
</blockquote>
<ul>
<li>概念 :
<ul>
<li>連結時機延後到執行期（run time）</li>
<li>Executable 不直接包含整套 library</li>
<li>只放 library function 的引用點（references）</li>
</ul>
</li>
<li>關鍵機制:
<ul>
<li>在 executable 中 ， 每個 library function 呼叫點 ， 插入一小段程式碼 → stub</li>
</ul>
</li>
</ul>
<p><img src="/img/OS_CH8_1.png" alt="alt text"></p>
<p>✅優點 : <strong>Memory Efficiency</strong></p>
<ul>
<li><strong>Single copy of library code shared across all processes</strong></li>
<li>多個程式使用同一個 library（如 libc）</li>
<li>RAM 中只需要一份 library code（共享）</li>
</ul>
<p>第一次呼叫 library function（First call）</p>
<ul>
<li>程式先跳到 stub</li>
<li>stub 檢查：
<ul>
<li>library 是否已載入</li>
<li>該 function symbol 是否已解析</li>
</ul>
</li>
<li>若尚未完成：
<ul>
<li>載入 library</li>
<li>解析 symbol（binding）</li>
</ul>
</li>
<li>跳到真正的 library function 執行</li>
</ul>
<p>後續呼叫（Subsequent calls）:</p>
<ul>
<li>不再做載入與解析</li>
<li>stub 已更新跳轉位址</li>
<li>直接跳到 function<br>
→ 執行速度接近 static linking</li>
</ul>
<h2 id="Static-Dynamic-Loading-Linking：Four-Combinations">Static / Dynamic Loading &amp; Linking：Four Combinations</h2>
<blockquote>
<p>Loading：什麼時候把 code 放進 RAM（startup vs on-demand）<br>
Linking：什麼時候把外部符號/library 接起來（link time vs run time）</p>
</blockquote>
<table>
<thead>
<tr>
<th>組合</th>
<th>Linking（連結）</th>
<th>Loading（載入）</th>
<th>Pros（優點）</th>
<th>Cons（缺點）</th>
<th>常見 Use case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>(1) Static Linking + Static Loading</strong></td>
<td>編譯/連結時全部打包</td>
<td>程式啟動時整包載入</td>
<td>最快、最單純、完全自給自足</td>
<td>Executable 最大、RAM 最浪費</td>
<td>Embedded、關鍵系統工具</td>
</tr>
<tr>
<td><strong>(2) Static Linking + Dynamic Loading</strong></td>
<td>仍是靜態連結（不共享）</td>
<td>用到模組才載入</td>
<td>起始 RAM 較省、不怕缺庫</td>
<td>跨 process 的 library duplication 仍存在</td>
<td>Plugin 架構</td>
</tr>
<tr>
<td><strong>(3) Dynamic Linking + Static Loading</strong></td>
<td>執行期解析、可共享</td>
<td>啟動時就載入所有 shared libraries</td>
<td>共享、省 RAM、更新較彈性</td>
<td>啟動較慢、可能載了用不到的庫</td>
<td>傳統 shared library</td>
</tr>
<tr>
<td><strong>(4) Dynamic Linking + Dynamic Loading (Lazy)</strong></td>
<td>執行期才解析</td>
<td>用到才載、用到才解析</td>
<td>最省 RAM、啟動快、彈性最高</td>
<td>第一次呼叫有 overhead、實作較複雜</td>
<td>大型應用、現代 OS 預設</td>
</tr>
</tbody>
</table>
<p>易混淆觀念對照</p>
<table>
<thead>
<tr>
<th>問題</th>
<th>正確理解</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Dynamic loading 是什麼？</strong></td>
<td>決定「<strong>程式碼何時進 RAM</strong>」（用到才載）</td>
</tr>
<tr>
<td><strong>Dynamic linking 是什麼？</strong></td>
<td>決定「<strong>何時解析/接上 library 符號</strong>」（執行期，靠 stub）</td>
</tr>
<tr>
<td><strong>差別一句話</strong></td>
<td>一個管 <strong>載入時機</strong>，一個管 <strong>連結解析時機</strong></td>
</tr>
<tr>
<td><strong>dlopen 算什麼？</strong></td>
<td>課件中視為 <strong>dynamic loading 的典型例子</strong>（實務上同時牽涉 loading + linking）</td>
</tr>
</tbody>
</table>
<hr>
<h1>Swapping</h1>
<h2 id="定義">定義 :</h2>
<ul>
<li>Swapping = 把整個 process 在 <strong>Memory</strong> 與 <strong>backing store</strong>之間搬移，之後可以再搬回來接著執行</li>
</ul>
<p>不同的點 :</p>
<ul>
<li>Scope : Entire process image</li>
<li>Scheduler : <strong>Medium-term scheduler operation</strong></li>
<li>Swapping vs Context Switch :
<ul>
<li>Swapping : 把 process 直接搬去 disk（人都不在 RAM 了）</li>
<li>Context Switch : 只是換 CPU 跑誰（process 都還在 RAM）</li>
</ul>
</li>
</ul>
<p><strong>Bccking Store</strong></p>
<ul>
<li>Dedicated disk partition separate from file system</li>
<li>direct block access to memory images</li>
<li>Must accommodate <strong>all swapped processes</strong></li>
</ul>
<p><strong>Swapping Triggers</strong></p>
<ul>
<li>Memory pressure : RAM 快不夠</li>
<li>Priority-based scheduling (Roll-out/Roll-in) : 高優先權的 process 需要 RAM → 把低優先權的「roll-out」出去</li>
</ul>
<h2 id="Swap-back-Memory-Address-Requirements">Swap-back Memory Address Requirements</h2>
<table>
<thead>
<tr>
<th>Binding 類型</th>
<th>Swap in 可否到不同位址？</th>
<th>原因（考試重點）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Compile-time binding</strong></td>
<td>❌ 不行（same address）</td>
<td>使用<strong>寫死的絕對位址</strong>，放到別的位址會造成所有指令位址錯誤</td>
</tr>
<tr>
<td><strong>Load-time binding</strong></td>
<td>❌ 不行（same address）</td>
<td><strong>Relocation 在載入時已完成</strong>，位址已被定死</td>
</tr>
<tr>
<td><strong>Execution-time binding</strong></td>
<td>✅ 可以（different address）</td>
<td>有 <strong>MMU</strong>，Logical → Physical 於 <strong>runtime</strong> 轉換，只需更新 base / page table</td>
</tr>
</tbody>
</table>
<h2 id="Swapping-I-O-Problem">Swapping: I/O Problem</h2>
<ul>
<li>The I/O Problem
<ul>
<li>Process P 正在等 I/O</li>
<li>OS 覺得 RAM 不夠 → 把 P swap out</li>
<li>I/O 完成時，DMA 會把資料寫到「P 原本的記憶體位置」</li>
</ul>
</li>
<li>結果：<strong>Data corruption</strong>（資料毀損）</li>
</ul>
<h2 id="Solution-to-I-O-Swapping-Conflict">Solution to I/O-Swapping Conflict:</h2>
<h3 id="Solution-1-Never-swap-processes-with-pending-I-O">Solution 1 : Never swap processes with pending I/O</h3>
<ul>
<li>swap 之前先檢查 I/O queue</li>
<li>I/O 進行中就把該 process 標記為 non-swappable</li>
</ul>
<h3 id="Solution-2-Use-OS-managed-I-O-buffers（kernel-buffer）">Solution 2 : Use OS-managed I/O buffers（kernel buffer）</h3>
<ul>
<li>I/O 不要直接寫到 user space 的 buffer</li>
<li>改成先寫到 kernel buffer（不會被 swap）</li>
<li>等 process swap 回來後，再把資料 copy 回 user space</li>
</ul>
<h2 id="Process-Swapping-to-Backing-Store">Process Swapping to Backing Store</h2>
<p>Swap time components :</p>
<ul>
<li><strong>Transfer Time (dominant factor)</strong> - Moving dadata between memory and disk</li>
</ul>
<blockquote>
<p><strong>正比於process size</strong> : process 越大搬越久</p>
</blockquote>
<ul>
<li>Latency : 磁碟的 seek + rotational delay</li>
<li>Context switch overhead - OS bookkeeping</li>
</ul>
<hr>
<h1>Memory Allocation Schemes (連續記憶體配置)</h1>
<h2 id="Fixed-Partition-Allocation">Fixed-Partition Allocation</h2>
<ul>
<li>做法 ： 系統一開機就把 RAM 切成<strong>固定大小的 partitions</strong></li>
<li>規則 ： 每個 process 只能佔一格 partition。
<ul>
<li>✅ <strong>Multiprogramming degree</strong> = partitions 數量
<ul>
<li>因為同時最多就塞得下「partition 個 process」</li>
</ul>
</li>
</ul>
</li>
<li><strong>Partition selection</strong> - First-fit or Best-fit within available partitions</li>
<li>✅ 優點：簡單（表格也說 Simple）</li>
<li>❌ 主要問題：<strong>Internal fragmentation（內部碎裂）</strong> - 因為 partition 固定大小，process 可能用不滿</li>
</ul>
<h2 id="Variable-Partition-Allocation">Variable-Partition Allocation</h2>
<ul>
<li>做法： 你要多少就切多少給你（依需求切一塊連續的）</li>
<li><strong>hole</strong>：一段連續的空閒記憶體區塊</li>
<li>多次 allocate/free 後，hole 會散落各處（各種大小）</li>
<li>✅ 優點：彈性高、初期利用率更好</li>
<li>❌ 主要問題：<strong>External fragmentation（外部碎裂）</strong></li>
</ul>
<h2 id="Multiple-Partition-Variable-Size-Method（可變分割到底怎麼運作）">Multiple Partition (Variable-Size) Method（可變分割到底怎麼運作）</h2>
<ul>
<li>如果要分配 ， 找一個夠大的hole 切下來分配，會變成一個較小的hole(split)</li>
<li>Data Structure
<ul>
<li><strong>Allocation Table（已配置表）</strong><br>
記每個 process 用哪一段：(PID, base, limit)</li>
<li><strong>Free List（空閒表）</strong>
<ul>
<li>記所有 holes：(base address, size)</li>
</ul>
</li>
<li>allocate/free 都要動態更新</li>
</ul>
</li>
<li>相鄰的 holes 應該自動合併（merge）</li>
<li>Implementation
<ul>
<li>allocate：如果 hole 比需求大 → 切割</li>
<li>deallocate：釋放後變 hole → 看左右是否也是 hole，能合就合</li>
</ul>
</li>
</ul>
<h2 id="Dynamic-Storage-Allocation-Problem">Dynamic Storage Allocation Problem</h2>
<blockquote>
<p>3個演算法</p>
</blockquote>
<ol>
<li>First-fit（第一個放得下就用）(O(n))
<ul>
<li>✅ 優點：平均最快</li>
<li>缺點：前面區域容易被切得很碎（很多小洞集中前面）</li>
</ul>
</li>
<li>Best-fit（找「最小但夠用」的 hole）(O(n))
<ul>
<li>✅ 好處：這次剩下的碎片最小（“看起來”很省）</li>
<li>❌ 壞處（投影片紅字）：會產生很多超小、用不到的洞</li>
</ul>
</li>
<li>Worst-fit（找最大的 hole）(O(n))
<ul>
<li>挑最大的 hole 來切</li>
<li>理論：留下的大碎片比較可能再放大 process</li>
</ul>
</li>
</ol>
<ul>
<li>First-fit 和 Best-fit 通常<strong>勝過</strong> Worst-fit</li>
<li>First-fit 通常<strong>最快</strong>，而且利用率跟 best-fit 差不多</li>
<li>Best-fit 不一定真的最優</li>
</ul>
<h2 id="Memory-Fragmentation">Memory Fragmentation</h2>
<h3 id="External-Fragmentation（外部碎裂）">External Fragmentation（外部碎裂）</h3>
<ul>
<li>Total free memory ≥ request size，但不連續（not contiguous）</li>
<li>出現在 Variable-size partition（可變分割）</li>
</ul>
<h3 id="Internal-Fragmentation（內部碎裂）">Internal Fragmentation（內部碎裂）</h3>
<ul>
<li>已分配出去的 partition 裡面，但 process 沒用到的空間</li>
<li>出現在 Fixed-partition（固定分割）</li>
</ul>
<h3 id="Solution-Memory-Compaction">Solution : <strong>Memory Compaction</strong></h3>
<p>把所有 processes「搬到一起」，把 holes 集中成一個大洞</p>
<ul>
<li>
<p>需要 <strong>Dynamic binding</strong>（execution-time binding）</p>
</li>
<li>
<p>Constraints :</p>
<ul>
<li>需要 relocatable code / MMU</li>
<li>overhead 很高：要搬「所有」process</li>
<li>系統可能要暫停/凍結 在 compaction 期間</li>
</ul>
</li>
</ul>
<hr>
<h1>Non-Contiguous Memory Allocation - Paging</h1>
<h2 id="Paging-Concept">Paging Concept</h2>
<ul>
<li>
<p>Core mechanism</p>
<ul>
<li>**Physical memory（實體記憶體 RAM）**切成固定大小小格子：叫 frames</li>
<li>**Logical memory（邏輯/虛擬位址空間）**也切成一樣大小小格子：叫 pages</li>
<li>page/frame 大小通常是 2 的次方（4KB、8KB…）
<ul>
<li>因為這樣「位址切割」可以用 bit 切：右邊 n bits 當 offset</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Process 要能執行，需要什麼？</p>
<ul>
<li>程式如果有 n pages，就需要 n 個可用 frames(不要求連續)</li>
</ul>
</li>
<li>
<p>OS 會維護：</p>
<ul>
<li><strong>free frame list</strong>：哪些 frame 還空著</li>
<li><strong>page table</strong>：把每個 page 對到哪個 frame（做位址轉換）</li>
</ul>
</li>
<li>
<p>Address translation</p>
<ul>
<li>Logical Address = [Page Number | Page Offset]<br>
→ (via page Table)→<br>
Pysical Address = [Frame Number | Page Offset]</li>
<li>重點：<strong>offset 不變</strong>（因為 page 和 frame 大小一樣）</li>
</ul>
</li>
</ul>
<h2 id="Paging-的-4-大好處">Paging 的 4 大好處</h2>
<p>這頁就是「為什麼 paging 比 variable partition 好」。</p>
<ol>
<li><strong>Noncontiguous</strong> allocation（可不連續）</li>
</ol>
<ul>
<li>pages 可以散落在任何 frames</li>
<li>OS 不用再煩惱找一大段連續洞</li>
</ul>
<ol start="2">
<li>Eliminates external fragmentation（消除外部碎裂）</li>
</ol>
<ul>
<li>因為不再需要連續的大洞</li>
<li>所有空間都以 frame 為單位可用</li>
</ul>
<blockquote>
<p>Paging 解掉 external fragmentation。</p>
</blockquote>
<ol start="3">
<li>Minimal internal fragmentation（仍有少量內部碎裂）</li>
</ol>
<ul>
<li>只可能發生在 最後一頁（因為程式大小不一定剛好整除 page size）</li>
<li>平均浪費：半頁 / process</li>
</ul>
<blockquote>
<p>Paging 沒有 external fragmentation，但有 internal fragmentation（平均半頁）。</p>
</blockquote>
<ol start="4">
<li>Enables memory sharing（支援共享）</li>
</ol>
<ul>
<li>多個 process 可以把某些頁 map 到同一個 physical frame</li>
<li>常見：<strong>共享的程式碼段</strong>（shared libraries）、共享記憶體</li>
</ul>
<h2 id="Page-table-fundamentals">Page table fundamentals</h2>
<ul>
<li>把 logical page number → physical frame number</li>
<li>每個 process 一張 page table</li>
<li>page table entry（PTE）至少要存：<strong>frame number</strong></li>
</ul>
<p>3 大特性 :</p>
<ol>
<li>Process isolation（隔離）</li>
<li>Memory protection（保護）</li>
<li>Address translation（轉換）</li>
</ol>
<h2 id="Address-Translation-Scheme">Address Translation Scheme</h2>
<p>Logical address 結構</p>
<ul>
<li>
<p>m-bit logical address</p>
<ul>
<li>page number <code>p</code>：m-n bits</li>
<li>offset <code>d</code>：n bits</li>
</ul>
</li>
<li>
<p><code>p</code>（page number）的意義</p>
<ul>
<li><code>p</code> 是 page table 的索引（index）</li>
<li>m-n bits → 最多可表示 2^(m-n) 個 pages</li>
<li>最大 logical memory：
<ul>
<li>pages 數量 2^(m-n) × 每頁大小 2^n bytes</li>
<li>= <code>2^m</code> bytes（剛好對應 m-bit 位址空間）</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>d</code>（page offset）的意義</p>
<ul>
<li><code>d</code> 是「在 page/frame 裡面的位移」</li>
<li>n bits → page size = 2^n bytes</li>
<li>translation 時 d 不變</li>
<li>最後 physical address = frame base address + d</li>
</ul>
</li>
</ul>
<p><strong>Translation formula</strong></p>
<ul>
<li>Physical Address = (Frame Number × Page Size) + Offset<br>
= Frame base + d</li>
</ul>
<h2 id="Address-Translation">Address Translation</h2>
<ul>
<li>Page size = 4KB = 2¹²→ Offset bits = 12</li>
</ul>
<blockquote>
<p>先看 page size → 算 offset bits<br>
位址總 bits − offset bits = page / frame number bits<br>
2^(number bits) = pages / frames 數量<br>
2^(address bits) = 最大記憶體大小</p>
</blockquote>
<ol>
<li>
<p>Logical Address Space（32-bit）</p>
<table>
<thead>
<tr>
<th>項目</th>
<th>計算</th>
<th>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logical address bits</td>
<td>已知</td>
<td>32 bits</td>
</tr>
<tr>
<td>Offset bits</td>
<td>4KB = 2¹²</td>
<td>12 bits</td>
</tr>
<tr>
<td><strong>Page number bits</strong></td>
<td>32 − 12</td>
<td><strong>20 bits</strong></td>
</tr>
<tr>
<td>Pages per process</td>
<td>2²⁰</td>
<td><strong>1M pages</strong></td>
</tr>
<tr>
<td>Max process size</td>
<td>2³² bytes</td>
<td><strong>4 GB</strong></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Physical Address Space（36-bit）</p>
<table>
<thead>
<tr>
<th>項目</th>
<th>計算</th>
<th>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Physical address bits</td>
<td>已知</td>
<td>36 bits</td>
</tr>
<tr>
<td>Offset bits</td>
<td>4KB = 2¹²</td>
<td>12 bits</td>
</tr>
<tr>
<td><strong>Frame number bits</strong></td>
<td>36 − 12</td>
<td><strong>24 bits</strong></td>
</tr>
<tr>
<td>Total frames</td>
<td>2²⁴</td>
<td><strong>16M frames</strong></td>
</tr>
<tr>
<td>Total physical memory</td>
<td>2³⁶ bytes</td>
<td><strong>64 GB</strong></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Page Table（每個 process）</p>
<table>
<thead>
<tr>
<th>項目</th>
<th>計算</th>
<th>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Page table 數量</td>
<td>每個 process 一張</td>
<td>1</td>
</tr>
<tr>
<td>Page table entries</td>
<td>= pages 數量</td>
<td><strong>2²⁰ = 1M entries</strong></td>
</tr>
</tbody>
</table>
</li>
</ol>
<h2 id="Page-Frame-Size-Considerations">Page/Frame Size Considerations</h2>
<ol>
<li>為什麼 page size 由硬體決定、且必須是 2 的次方？</li>
</ol>
<ul>
<li>因為位址要用 bit 切：
<ul>
<li>低 n bits = offset</li>
<li>高位 = page/frame number</li>
</ul>
</li>
<li>不是 2 的次方就不好用位元運算切割</li>
</ul>
<ol start="2">
<li>常見大小與趨勢</li>
</ol>
<ul>
<li>常見：4KB、8KB</li>
<li>範圍：512B 到 16MB</li>
<li>現代也有 huge pages（2MB、1GB）給特定工作負載</li>
</ul>
<ol start="3">
<li>Internal fragmentation 分析</li>
</ol>
<ul>
<li>平均每個 process 的內部碎裂 ≈ page_size / 2</li>
<li><strong>page 越大 → 浪費越多</strong>（最後一頁平均半頁浪費會變大）</li>
</ul>
<ol start="4">
<li>為什麼歷史上 page size 變大？</li>
</ol>
<ul>
<li>記憶體系統變大（GB/TB 時代）</li>
<li>dataset 變大（DB、科學運算）</li>
<li>I/O 最佳化：page fault overhead 相對變高，頁大可以減少 fault 次數（某些情境）</li>
<li>TLB 壓力：TLB entries 有限，頁大可以讓 TLB cover 更多記憶體（TLB reach 變大）</li>
</ul>
<h2 id="Paging-Summary">Paging Summary</h2>
<ol>
<li>Memory Abstraction Achievement</li>
</ol>
<table>
<thead>
<tr>
<th>使用者看到</th>
<th>OS / 硬體實際做的</th>
</tr>
</thead>
<tbody>
<tr>
<td>連續的 logical address space</td>
<td>Pages 分散在不連續的 frames</td>
</tr>
<tr>
<td>0 ～ max 的連續空間</td>
<td>MMU + page table 做轉換</td>
</tr>
<tr>
<td>感覺不到搬家</td>
<td>位址轉換對程式 <strong>透明</strong></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>OS 兩大關鍵資料結構</li>
</ol>
<p><strong>Page Table（per-process）</strong></p>
<table>
<thead>
<tr>
<th>項目</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>數量</td>
<td>每個 process 一張</td>
</tr>
<tr>
<td>功能</td>
<td>Logical pages → Physical frames</td>
</tr>
<tr>
<td>提供</td>
<td>隔離、保護</td>
</tr>
<tr>
<td>Context switch</td>
<td>需要切換 page table base</td>
</tr>
</tbody>
</table>
<p><strong>Frame Table（system-wide）</strong></p>
<table>
<thead>
<tr>
<th>項目</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>數量</td>
<td>全系統一張</td>
</tr>
<tr>
<td>對象</td>
<td>每個 physical frame 一個 entry</td>
</tr>
<tr>
<td>記錄內容</td>
<td>free / allocated</td>
</tr>
<tr>
<td>若被佔用</td>
<td>owner：PID + page#（共享則是清單）</td>
</tr>
<tr>
<td>其他 metadata</td>
<td>reference count、dirty bit、lock status…</td>
</tr>
</tbody>
</table>
<hr>
<h1>Implementation of Page Table</h1>
<ol>
<li>Page table 存放（Storage）</li>
</ol>
<ul>
<li>Page tables reside in <strong>main memory</strong> (too large for registers)</li>
<li><strong>PTBR（Page-Table Base Register）</strong>
<ul>
<li>存「這個 process 的 page table 在實體記憶體的起始位址」</li>
</ul>
</li>
<li>PTBR <strong>存在 PCB(Process Control Block)</strong></li>
<li>所以 context switch 時，OS 會把新 process 的 PTBR 載入（等於換一張 page table）</li>
</ul>
<ol start="2">
<li>Memory access overhead</li>
</ol>
<ul>
<li>
<p>沒有 TLB 時，每次存取一個 logical address 要做兩次記憶體存取：</p>
<ul>
<li>先去 memory 裡找 page table entry（用 PTBR + page#）</li>
<li>再去 memory 裡拿真正資料（frame# + offset）</li>
</ul>
<table>
<thead>
<tr>
<th>情況</th>
<th>你要拿到「資料」前要做什麼</th>
<th style="text-align:right">需要幾次 memory access</th>
</tr>
</thead>
<tbody>
<tr>
<td>沒有 TLB</td>
<td>先查 page table，再讀資料</td>
<td style="text-align:right">2</td>
</tr>
<tr>
<td>有 TLB 且 hit</td>
<td>直接得到 frame#，讀資料</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>有 TLB 但 miss</td>
<td>查 page table + 讀資料</td>
<td style="text-align:right">2</td>
</tr>
</tbody>
</table>
</li>
</ul>
<ol start="3">
<li>Solution：TLB</li>
</ol>
<ul>
<li><strong>TLB = Translation Look-aside Buffer</strong>
<ul>
<li>是在 MMU 裡的硬體 cache</li>
<li>記最近用過的 page→frame 對應</li>
<li>目的：讓大多數存取變成「一次 memory access」</li>
</ul>
</li>
</ul>
<h2 id="Associative-Memory-CAM">Associative Memory / CAM</h2>
<p>TLB 用的記憶體型態是 Associative Memory / CAM（Content-Addressable Memory）</p>
<ul>
<li>
<p>特色：不是用「位址」找資料，而是用「內容」找。</p>
</li>
<li>
<p>Key characteristics</p>
<ul>
<li>
<p>Parallel search：所有 entries 同時比對</p>
</li>
<li>
<p>Search by content：輸入 page number（通常還會加 ASID），輸出 frame number</p>
</li>
<li>
<p>Access time O(1)：不管幾筆，都像一次查找</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>項目</th>
<th>CAM / TLB 的特性</th>
<th>代價</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找速度</td>
<td>平行比對，接近 O(1)</td>
<td>電路複雜、成本高</td>
</tr>
<tr>
<td>功耗</td>
<td>多路同時比較</td>
<td>耗電高</td>
</tr>
<tr>
<td>容量</td>
<td>不能太大（64–1024 entries）</td>
<td>命中率受限</td>
</tr>
</tbody>
</table>
<ul>
<li>Performance characteristics
<ul>
<li>TLB hit： 只要 1 次 memory access（直接去拿 data）</li>
<li>TLB miss： 變回 2 次（page table + data）</li>
<li>Replacement policy：常見 LRU（TLB 滿了要踢誰）</li>
</ul>
</li>
</ul>
<h2 id="Translation-Lookaside-Buffer-TLB">Translation Lookaside Buffer (TLB)</h2>
<p>TLB 是什麼？</p>
<ul>
<li>「硬體快取」保存最近的 virtual→physical 轉換</li>
<li>shared by all processes（同一顆 CPU 的 TLB 不是每個 process 一份）</li>
</ul>
<p>但 shared 會有問題：context switch 後，舊 process 的轉換還留在 TLB</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>做法</th>
<th>優點</th>
<th>缺點</th>
</tr>
</thead>
<tbody>
<tr>
<td>Option 1：Flush TLB</td>
<td>context switch 時整個 TLB 清空</td>
<td>簡單、安全</td>
<td>很貴：切換後命中率掉，變慢</td>
</tr>
<tr>
<td>Option 2：ASID tag</td>
<td>每個 TLB entry 加上 ASID(PID) 標籤</td>
<td>不用清空，效能好</td>
<td>硬體較複雜，要有 ASID 支援</td>
</tr>
</tbody>
</table>
<h2 id="EMAT（Effective-Memory-Access-Time）">EMAT（Effective Memory-Access Time）</h2>
<blockquote>
<p>「平均一次記憶體存取要多久」，取決於 hit ratio。</p>
</blockquote>
<p>公式 :<br>
$$<br>
EMAT = TLB hit ratio * TLB hit Time + (1 - hit ratio) * miss Time<br>
$$</p>
<h2 id="Memory-Protection（Page-table-entry-裡的保護位）">Memory Protection（Page table entry 裡的保護位）</h2>
<p>常見 protection bits</p>
<ul>
<li>R/W/X：可讀、可寫、可執行</li>
</ul>
<p>Valid/Invalid bit</p>
<ul>
<li>Valid vs Invalid（這是 OS 保護的關鍵）
<ul>
<li>Valid (v)：此 page 在該 process 合法的 logical address space 內，可被存取</li>
<li>Invalid (i)：不在合法範圍內
<ul>
<li>程式一旦存取 invalid page → page fault（trap to OS）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Valid-Invalid Bit：Implementation Issues</strong></p>
<p>Issue 1：Unused page table entries</p>
<ul>
<li>process 不一定用滿整個 logical space<br>
但傳統 page table 看起來像要準備「所有可能 pages」的 entries（很浪費）</li>
<li>解法：PTLR（Page Table Length Register）</li>
</ul>
<p>Issue 2：Non-page-aligned process memory</p>
<ul>
<li>process 的「結束位址」可能不剛好切齊 page boundary</li>
<li>所以最後一頁裡面會有一段「在 valid page 裡，但其實超出程式真正大小」的區域 <strong>valid but illegal</strong></li>
<li>解法：還需要 limit registe</li>
</ul>
<table>
<thead>
<tr>
<th>機制</th>
<th>管什麼</th>
<th>解決哪個問題</th>
</tr>
</thead>
<tbody>
<tr>
<td>PTLR</td>
<td>page table 有效 entries 的數量/範圍</td>
<td>防止存取超出「最後一個 page」之外</td>
</tr>
<tr>
<td>limit register</td>
<td>process 真正結束的「位址」</td>
<td>防止存取最後一頁內「valid page 但超出程式大小」的區域</td>
</tr>
</tbody>
</table>
<h2 id="Shared-Pages">Shared Pages</h2>
<ul>
<li>Paging 可以讓多個 process 共享同一份 code</li>
</ul>
<blockquote>
<p>共享的前提：shared code 必須是 reentrant（pure code）</p>
</blockquote>
<p>重點特性：</p>
<ul>
<li>Read-only：執行中不修改（不然大家改同一份會互相影響）</li>
<li>Self-contained：不依賴每個 process 自己的私有狀態</li>
</ul>
<p>Memory efficiency :</p>
<ul>
<li>
<p>物理記憶體只放 <strong>一份</strong> shared code</p>
</li>
<li>
<p>多個 process 的不同 virtual addresses都可以 map 到<strong>同一個 physical frame</strong></p>
</li>
<li>
<p>每個 process 仍<strong>保有自己的 private</strong> : data、heap、stack、process-specific code</p>
</li>
</ul>
<h2 id="Shared-Pages-via-Page-Tables">Shared Pages via Page Tables</h2>
<blockquote>
<p>共享的 code 必須出現在所有共享 process 的 <strong>same virtual address</strong><br>
Why ?</p>
</blockquote>
<ul>
<li>reentrant code 仍可能含 <strong>position-dependent instructions</strong>
<ul>
<li>例如 jump/call 用「相對位址」或某些基於位置的計算</li>
</ul>
</li>
<li>如果同一份 shared code 在不同 process 被映射到不同 virtual address<br>
→ 這些位置相關指令可能指到錯地方</li>
</ul>
<h2 id="Page-Table-Structure：Scalability-Problem">Page Table Structure：Scalability Problem</h2>
<blockquote>
<p>「單層 page table 會爆炸」</p>
</blockquote>
<p>Challenges :</p>
<ul>
<li>page table 太大，不可能放 registers/cache</li>
<li>放在 memory 又會影響效能</li>
<li>sparse address space：很多 entries 根本用不到，卻佔空間</li>
</ul>
<p>Design goals:</p>
<ul>
<li>
<p>把大 page table 切成小單元（理想每單元 ≤ 4KB）</p>
</li>
<li>
<p>降低總 memory overhead</p>
</li>
<li>
<p>仍要能有效Translation</p>
</li>
</ul>
<p>Solutions</p>
<ul>
<li>Hierarchical (multi-level) paging：多層頁表（常見）</li>
<li>Hashed page tables：用 hash 減少表大小（大位址空間用）</li>
<li>Inverted page tables：每個 physical frame 一筆（不是每個 virtual page 一筆）</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>核心想法</th>
<th>直覺記法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Multi-level paging</td>
<td>只為「用到的那部分」建下一層表</td>
<td>用到才展開</td>
</tr>
<tr>
<td>Hashed page table</td>
<td>virtual page 先 hash，查 bucket</td>
<td>用雜湊縮小查找</td>
</tr>
<tr>
<td>Inverted page table</td>
<td>以 physical frame 為主，一 frame 一 entry</td>
<td>表大小跟 RAM 成正比</td>
</tr>
</tbody>
</table>
<h2 id="Hierarchical-Paging、Hashed-Page-Table、Inverted-Page-Table-IPT">Hierarchical Paging、Hashed Page Table、Inverted Page Table, IPT</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>核心想法</th>
<th>適合用在哪</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Hierarchical Paging</strong>（多層頁表）</td>
<td>把「超大的頁表」切成多層，用<strong>索引分段</strong>，只為用到的區塊配置下層表</td>
<td>常見 CPU 架構（x86-64/ARM64），通用、穩</td>
</tr>
<tr>
<td><strong>Hashed Page Table</strong>（雜湊頁表）</td>
<td>用 <strong>hash(VPN)</strong> 快速定位可能的頁表項，碰撞就用 chain（鏈結串列）</td>
<td>超大位址空間、而且很<strong>稀疏</strong>（很多虛擬頁根本沒用到）</td>
</tr>
<tr>
<td><strong>IPT</strong>（反向頁表）</td>
<td>不再「每個虛擬頁一筆」，改成「每個<strong>實體 frame 一筆</strong>」→ 整台機器只有一張表</td>
<td>64-bit 大系統想大幅省頁表記憶體，但查找會更麻煩</td>
</tr>
</tbody>
</table>
<blockquote>
<p>VPN = Virtual Page Number（虛擬頁號），PFN/Frame# = Physical Frame Number（實體 frame 編號）</p>
</blockquote>
<h3 id="Hierarchical-paging的目標：「頁表不要一次整張都配置，用到哪一段才開哪一段。」">Hierarchical paging的目標：「頁表不要一次整張都配置，用到哪一段才開哪一段。」</h3>
<ul>
<li>Logical address = [ p1 | p2 | d ]</li>
<li>只有當某段虛擬位址真的被用到，才需要那張 inner table 存在</li>
<li>Example :<br>
<img src="/img/TwoLevelH.png" alt="alt text"></li>
<li>結論：不實際。</li>
</ul>
<h3 id="Hashed-page-table-想用-hash-直接跳到「可能的位置」，少走好幾層。">Hashed page table : 想用 hash 直接跳到「可能的位置」，少走好幾層。</h3>
<ul>
<li>
<p>核心結構：</p>
<ul>
<li>用 VPN 做 hash：index = hash(VPN)</li>
<li>hash_table[index] 指向一條 chain（linked list）</li>
<li>chain 每個節點通常包含：
<ul>
<li>VPN（用來比對是不是你要的）</li>
<li>PFN/frame（對應到哪個實體 frame）</li>
<li>next pointer（下一個節點）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>缺點:</p>
<ul>
<li>Collision 造成 chain 變長
<ul>
<li>table 越大 → collision 越少 → chain 越短 → 越快</li>
<li>table 越小 → collision 越多 → chain 越長 → 越慢</li>
</ul>
</li>
<li>指標開銷（尤其 64-bit 指標 8 bytes）
<ul>
<li>每個節點/entry 需要 pointer，記憶體會多一些。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Translation</p>
<ul>
<li>
<p>取出 VPN（p）</p>
</li>
<li>
<p>算 index = hash(VPN)</p>
</li>
<li>
<p>到 hash table 的那個 bucket</p>
</li>
<li>
<p>沿著 chain 一個個比 VPN</p>
</li>
<li>
<p>找到 → 拿 frame number；找不到 → page fault</p>
</li>
</ul>
</li>
</ul>
<h3 id="Inverted-Page-Table">Inverted Page Table</h3>
<ul>
<li>
<p>IPT：整台機器 只有一張表</p>
</li>
<li>
<p>每個實體 frame 一筆</p>
<ul>
<li>一筆內容大概是：</li>
<li><strong>PID(Process ID)</strong>：這個 frame 現在屬於哪個 process</li>
<li><strong>VPN(Virtual Page Number)</strong>：對應到該 process 的哪個虛擬頁</li>
<li>control bits（valid/dirty/reference/protection…）</li>
</ul>
</li>
<li>
<p>所以表大小 ≈ <strong>實體記憶體有多少 frames</strong></p>
</li>
<li>
<p>Translation:</p>
<ul>
<li>
<p>CPU 給 logical address，現在會是：</p>
<ul>
<li>
<p>PID（當前 process）</p>
</li>
<li>
<p>VPN（p）</p>
</li>
<li>
<p>offset（d）</p>
</li>
</ul>
</li>
<li>
<p>目標是找到「哪個 frame i 對應到 (PID, VPN)」</p>
</li>
<li>
<p>整張 IPT 從頭掃到尾找 (PID,VPN) ⇒ O(n)（n = frames 數）很慢</p>
</li>
<li>
<p>會用 <strong>hash</strong>(PID, VPN) 加速（平均查找時間下降），而且還是要靠 <strong>TLB</strong> 才能實用。</p>
</li>
</ul>
</li>
</ul>
<p>IPT 的共享記憶體（shared pages）為什麼麻煩？</p>
<ul>
<li>
<p><strong>多個 process 的不同 VPN，要映到同一個 PFN/frame</strong></p>
</li>
<li>
<p>但 IPT 每個 frame 通常只放 一組 (PID, VPN)<br>
所以共享時會卡住：「這個 frame 到底要記誰的 PID/VPN？」</p>
</li>
<li>
<p>IPT shared-memory 三個解法比較表</p>
<table>
<thead>
<tr>
<th>解法</th>
<th>怎麼做</th>
<th>優點</th>
<th>缺點/代價</th>
<th>你可以怎麼記</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Allow multiple entries per frame</strong></td>
<td>一個 frame 對應多組 (PID,VPN)（像一對多清單）</td>
<td>最直觀，能完整表示共享</td>
<td>查找/維護更複雜；每個 frame entry 變大（更多記憶體）</td>
<td>「frame 裡放名冊」</td>
</tr>
<tr>
<td><strong>Separate data structure for shared pages</strong></td>
<td>IPT 維持 private pages；共享頁另外有一張結構（shared table）記映射</td>
<td>IPT 本體簡潔；共享管理集中</td>
<td>多一套資料結構要同步維護；系統更複雜</td>
<td>「共享另開一本簿」</td>
</tr>
<tr>
<td><strong>Hybrid approach</strong></td>
<td><strong>private pages 用 IPT</strong>；<strong>shared pages 用傳統 page table</strong></td>
<td>實務上常用的折衷：省很多又能處理共享</td>
<td>兩套機制並存，設計更複雜</td>
<td>「私用走 IPT，共享走傳統」</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>總比較:</p>
<table>
<thead>
<tr>
<th>面向</th>
<th>Hierarchical Paging</th>
<th>Hashed Page Table</th>
<th>Inverted Page Table (IPT)</th>
</tr>
</thead>
<tbody>
<tr>
<td>頁表以誰為單位</td>
<td>每個 process 一套（多層）</td>
<td>通常每個 process 一套（hash 結構）</td>
<td>全系統一套（每個 frame 一筆）</td>
</tr>
<tr>
<td>主要解決</td>
<td>頁表太大 → 分層、按需配置</td>
<td>64-bit 稀疏空間 → 用 hash 快找</td>
<td>頁表記憶體爆炸 → 表大小跟 frames 綁定</td>
</tr>
<tr>
<td>TLB miss 時成本</td>
<td>要走多層（層數越多越慢）</td>
<td>hash + traverse chain</td>
<td>找 (PID,VPN)→frame（常搭 hash）</td>
</tr>
<tr>
<td>最大優點</td>
<td>通用、硬體常見、好保護</td>
<td>稀疏時省、可快</td>
<td>省頁表記憶體「非常多」</td>
</tr>
<tr>
<td>最大缺點</td>
<td>層數多時，TLB miss 很痛</td>
<td>collision/chain 會拖慢；指標開銷</td>
<td>共享頁麻煩；查找複雜，仍需 TLB</td>
</tr>
</tbody>
</table>
<hr>
<h1>Segmentation</h1>
<p>Segmentation = 讓記憶體看起來像「程式設計師理解的模組」</p>
<blockquote>
<p>跟 Paging 最大差別：<br>
Paging 把記憶體切成固定大小 page/frame（對程式員「看不見」）<br>
Segmentation 直接用程式的邏輯結構來切（對程式員「看得懂」）</p>
</blockquote>
<p>重要特性 :</p>
<ul>
<li>每個 segment <strong>有名稱或編號</strong>（segment number）</li>
<li>segment 大小是<strong>可變的</strong>（variable size）</li>
<li>每個 segment 都是<strong>語意上有意義的單位</strong></li>
<li>不同 segment 可有<strong>不同權限</strong>（例如 code：可執行但唯讀；data：可讀寫）</li>
</ul>
<p>Segmentation 的 Logical Address</p>
<ul>
<li>Logical Address = &lt;segment number,offset&gt;
<blockquote>
<p>s (segment number)：你要存取哪一段（第幾段）<br>
d (offset)：在該段裡面第幾個 byte</p>
</blockquote>
</li>
</ul>
<p>每個 segment 在實體記憶體中可以被放在任何地方（不必連續、也不必靠在一起）</p>
<blockquote>
<p>注意：每個 segment 自己本身通常需要一塊連續的實體空間（因為它是 base+offset 這種算法）。</p>
</blockquote>
<h2 id="Segmentation-Table（分段表）">Segmentation Table（分段表）</h2>
<table>
<thead>
<tr>
<th>欄位</th>
<th>意思</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>base</strong></td>
<td>這個 segment 在 <strong>physical memory 的起始位址</strong></td>
<td>用來做 base + offset</td>
</tr>
<tr>
<td><strong>limit</strong></td>
<td>這個 segment 的<strong>長度</strong>（或最大合法 offset）</td>
<td>用來做保護/界限檢查</td>
</tr>
</tbody>
</table>
<h2 id="硬體暫存器：STBR-STLR">硬體暫存器：STBR / STLR</h2>
<blockquote>
<p>每個 process 都有自己的 segment table」，所以硬體要知道</p>
<ul>
<li>這張表在哪？</li>
<li>這張表多長？（有幾個 segments）</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>暫存器</th>
<th>全名</th>
<th>放什麼</th>
<th>何時更新</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>STBR</strong></td>
<td>Segment-Table Base Register</td>
<td>segment table 在<strong>實體記憶體的起始位址</strong></td>
<td>context switch 換行程時</td>
</tr>
<tr>
<td><strong>STLR</strong></td>
<td>Segment-Table Length Register</td>
<td>這個行程有幾個 segments</td>
<td>context switch 換行程時</td>
</tr>
</tbody>
</table>
<blockquote>
<p>STLR 的用意：避免你用不存在的 segment number<br>
若 s ≥ STLR → 直接 trap（非法段）</p>
</blockquote>
<h2 id="Translation">Translation</h2>
<p>給定 logical address ⟨𝑠,𝑑⟩</p>
<ol>
<li>
<p>Step 1：段號合法嗎？</p>
<ul>
<li>如果 s ≥ STLR → TRAP（segment fault）</li>
</ul>
</li>
<li>
<p>Step 2：去 segment table 拿 entry</p>
<ul>
<li>entry_address = STBR + s × entry_size</li>
<li>讀出 base 與 limit</li>
</ul>
</li>
<li>
<p>Step 3：offset 合法嗎？</p>
<ul>
<li>如果 d ≥ limit → TRAP（越界）</li>
</ul>
</li>
<li>
<p>Step 4：算 physical address</p>
<ul>
<li>PA=base+d</li>
</ul>
</li>
<li>
<p>Step 5：去記憶體存取資料</p>
<ul>
<li>Memory access cost（為什麼這頁提成本）</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>如果沒快取（像 TLB）：</p>
<ul>
<li>
<p>第 1 次 memory access：讀 segment table entry（base/limit）</p>
</li>
<li>
<p>第 2 次 memory access：讀真正資料<br>
→ 所以是 2 次 memory access / 每次位址轉換</p>
</li>
</ul>
</li>
</ul>
<h2 id="MMU-會做三件事">MMU 會做三件事</h2>
<ul>
<li>
<p>做 address translation（logical → physical）</p>
</li>
<li>
<p>做 bounds checking（用 limit 檢查 d）</p>
</li>
<li>
<p>違規就產生 trap（保護）</p>
</li>
</ul>
<blockquote>
<p>Segmentation =（STBR 找表）→（s 找 entry）→（limit 檢查 d）→（base + d）</p>
</blockquote>
<h2 id="Segmentation-vs-Paging">Segmentation vs Paging</h2>
<p>Logical address 格式比較</p>
<table>
<thead>
<tr>
<th>Scheme</th>
<th>Logical Address Format</th>
<th>你在指定什麼</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Segmentation</strong></td>
<td>⟨segment#, offset⟩</td>
<td>「第幾段」+「段內位移」</td>
</tr>
<tr>
<td><strong>Paging</strong></td>
<td>⟨page#, offset⟩</td>
<td>「第幾頁」+「頁內位移」</td>
</tr>
</tbody>
</table>
<p>Table entry 結構比較</p>
<table>
<thead>
<tr>
<th>項目</th>
<th>Segmentation Table Entry</th>
<th>Page Table Entry</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心欄位</td>
<td><strong>base + limit + control bits</strong></td>
<td><strong>frame# + control bits</strong></td>
</tr>
<tr>
<td>為什麼要 limit</td>
<td>segment <strong>大小可變</strong>，必須防越界</td>
<td>page <strong>固定大小</strong>，offset 天生不會超過 page size</td>
</tr>
<tr>
<td>放置方式</td>
<td>每段在實體記憶體可放任意起點（base 任意）</td>
<td>frame 起點 = frame# × page_size（固定對齊）</td>
</tr>
</tbody>
</table>
<h2 id="Sharing-of-Segments">Sharing of Segments</h2>
<blockquote>
<p>共享 = 兩個 process 的 segment table entry 指向同一個 physical base<br>
Segmentation 很自然支援共享：把「同一段」映射到「同一塊實體記憶體」</p>
</blockquote>
<h2 id="Protection-and-Sharing-in-Segmentation">Protection and Sharing in Segmentation</h2>
<blockquote>
<p>分段的每個 segment entry 不只有 base/limit，還有 <strong>protection bits</strong>；<br>
共享就是「不同 process 的 segment table 指到同一塊實體記憶體（同一個 base）」。</p>
</blockquote>
<ul>
<li>
<p>Segment Entry: [ Base | Limit | Protection Bits ] ← R/RW/RX/RWX</p>
<ul>
<li>Base：這個 segment 在記憶體中的起始位址（實務上可理解為線性/實體某個起點，取決於你的架構）</li>
<li>Limit：segment 的長度（或最大合法 offset）</li>
<li>Protection Bits：權限控制</li>
</ul>
</li>
<li>
<p>Code sharing occurs at <strong>segment level</strong></p>
<ul>
<li>整包 code 一段（text segment）</li>
<li>整包 data 一段（data segment）</li>
<li>stack 一段、heap 一段</li>
<li>shared lib 一段</li>
</ul>
</li>
<li>
<p>Key Principle：每次存取都檢查保護；共享靠共同映射</p>
</li>
</ul>
<hr>
<h1>Segmentation with Paging</h1>
<ul>
<li>Apply segmentation in logical address space
<ul>
<li>程式員/OS 想像中的記憶體（Logical / Virtual view）→ 用 Segmentation</li>
</ul>
</li>
<li>Apply paging in physical address space
<ul>
<li>真正硬體的 RAM（Physical memory）→ 用 Paging</li>
</ul>
</li>
</ul>
<p>Address Translation（logical → linear → physical）</p>
<table>
<thead>
<tr>
<th>名稱</th>
<th>你可以把它想成</th>
<th>由誰產生/看到</th>
<th>下一步</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Logical address</strong>（邏輯位址）</td>
<td>「程式用的位址」(常見：<code>&lt;segment, offset&gt;</code> 或虛擬位址)</td>
<td>CPU 在執行指令時產生</td>
<td>交給 <strong>segmentation unit</strong></td>
</tr>
<tr>
<td><strong>Linear address</strong>（線性位址）</td>
<td>「把 segment 翻譯完後的結果」：一條 0…max 的連續位址</td>
<td>segmentation unit 輸出</td>
<td>交給 <strong>paging unit</strong></td>
</tr>
<tr>
<td><strong>Physical address</strong>（實體位址）</td>
<td>真正 RAM 上的位置</td>
<td>paging unit 輸出</td>
<td>去 RAM 讀/寫</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://YowDesert.github.io">YowDesert</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://yowdesert.github.io/posts/6575bc75.html">https://yowdesert.github.io/posts/6575bc75.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://YowDesert.github.io" target="_blank">YD's 資訊學習筆記</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/">作業系統</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="ads-wrap"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5975504062599634" crossorigin="anonymous"></script> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5975504062599634" data-ad-slot="7226702911" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/8075d89.html" title="(作業系統) Virtual Memory Operation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">(作業系統) Virtual Memory Operation</div></div><div class="info-2"><div class="info-item-1">快速導覽 讓程式覺得自己有很大的連續記憶體（Virtual Address Space），但實際上只把「目前真的會用到的那部分」放在 RAM。 不夠的時候再把頁面換進換出（paging in/out）。  Virtual Memory = 用「需求載入（demand paging）」+「頁面置換（page replacement）」來用小 RAM 撐起大程式。    為什麼 VM 可行？  因為程式有 locality of reference（只會密集使用一小段頁面）。    Demand Paging 是怎麼運作的？  page table 的 valid/invalid bit + page fault 例外處理流程。    Page fault 為什麼會讓效能炸掉？  因為牽涉 disk I/O，所以 page fault rate 要非常非常小；會用 EAT（effective access time） 去算。    沒有 free frame 時怎麼辦？  用 page replacement，挑 victim page；dirty 的還要先寫回。    frames...</div></div></div></a><a class="pagination-related" href="/posts/862ca019.html" title="Diffie–Hellman (DH) Key Exchange (金鑰交換)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Diffie–Hellman (DH) Key Exchange (金鑰交換)</div></div><div class="info-2"><div class="info-item-1"> Diffie–Hellman 是一個金鑰交換的演算法   DH 在解決什麼問題？  在不安全通道上，Alice 與 Bob 協議出共同秘密金鑰 $K$，用於對稱加密（如 AES）。  公開參數  質數 $p$ 生成元 $g$ 所有運算皆在 $\bmod p$ 下進行。  協議流程 Alice 選私鑰 $a$，公開 $A=g^a \bmod p$。 Bob 選私鑰 $b$，公開 $B=g^b \bmod p$。 共享秘密：  Alice：$K=B^a \bmod p$ Bob：$K=A^b \bmod p$ 正確性：$(g^b)^a \equiv (g^a)^b \equiv g^{ab}\pmod p$。   注意 : 不是 $(g^a) \times cross (g^b) = g^{a+b}$  手算例 選 $p=23, g=5$。 Alice：$a=6 \Rightarrow A=5^6 \bmod 23=8$。 Bob：$b=15 \Rightarrow B=5^{15} \bmod 23=19$。 共享：  $K=19^6 \bmod 23=2$ $K=8^{15} ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/67c68839.html" title="(作業系統) Deadlock Definition, Avoidance and Resolution"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-13</div><div class="info-item-2">(作業系統) Deadlock Definition, Avoidance and Resolution</div></div><div class="info-2"><div class="info-item-1">Deadlock基本概念 1. Deadlock 是什麼？ Deadlock 指的是：  一組 processes 彼此等待對方所持有的資源，導致所有 process 都無法繼續執行。  Deadlock 的特徵  每個 process：  已持有至少一個資源 同時等待另一個 process 持有的資源   結果：大家互等，系統停住   2. Deadlock 範例 Example 1：兩個 processes、兩個資源  P1 持有 R1，等待 R2 P2 持有 R2，等待 R1 → 互相等待，發生 deadlock  Example 2：Semaphore A 與 B 12P1: wait(A); wait(B); ...; signal(B); signal(A);P2: wait(B); wait(A); ...; signal(A); signal(B);  若 P1 先拿到 A、P2 先拿到 B 下一步彼此都在等對方 → deadlock   Deadlock 的四個必要條件 Deadlock 當且僅當下列四個條件同時成立：  Mutual Exclusion（互斥）...</div></div></div></a><a class="pagination-related" href="/posts/90aa57da.html" title="(作業系統) Process and Concurrency - Synchronization Concepts"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="info-item-2">(作業系統) Process and Concurrency - Synchronization Concepts</div></div><div class="info-2"><div class="info-item-1">簡短說明：  主題：Synchronization Concepts 本章重點：  什麼情況下會發生 Race Condition？ 作業系統必須滿足哪些條件，才能正確管理共享資源？ 有哪些同步機制（Synchronization Mechanisms）可以保證程式正確性？      Background 問題與解決   The Problem :  Concurrent access to shared data may result in data inconsistency Outcome depends on the order of execution(race condition)    The Solution :  Ensure orderly execution Synchronization : 協調資源的分享與存取 保證 Data Integrity 和 Correctness    Consumer and Producer Problem :   變數意義 :  in：下一個要放入的位置（next free position） out：下一個要取出的項目...</div></div></div></a><a class="pagination-related" href="/posts/8075d89.html" title="(作業系統) Virtual Memory Operation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-20</div><div class="info-item-2">(作業系統) Virtual Memory Operation</div></div><div class="info-2"><div class="info-item-1">快速導覽 讓程式覺得自己有很大的連續記憶體（Virtual Address Space），但實際上只把「目前真的會用到的那部分」放在 RAM。 不夠的時候再把頁面換進換出（paging in/out）。  Virtual Memory = 用「需求載入（demand paging）」+「頁面置換（page replacement）」來用小 RAM 撐起大程式。    為什麼 VM 可行？  因為程式有 locality of reference（只會密集使用一小段頁面）。    Demand Paging 是怎麼運作的？  page table 的 valid/invalid bit + page fault 例外處理流程。    Page fault 為什麼會讓效能炸掉？  因為牽涉 disk I/O，所以 page fault rate 要非常非常小；會用 EAT（effective access time） 去算。    沒有 free frame 時怎麼辦？  用 page replacement，挑 victim page；dirty 的還要先寫回。    frames...</div></div></div></a><a class="pagination-related" href="/posts/cf6482ff.html" title="(作業系統) File System"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-21</div><div class="info-item-2">(作業系統) File System</div></div><div class="info-2"><div class="info-item-1">快速摘要   檔案與目錄是什麼抽象？OS 提供哪些操作？   檔案本質上是「一串位元組（bytes）」的邏輯視圖   目錄的工作是把 name → 檔案的 metadata（inode/FCB） 對起來   常見操作：create/open/read/write/seek/close/delete/truncate，以及目錄的 search/rename/traverse 等     檔案系統內部要維護哪些關鍵資料結構？（磁碟上 vs 記憶體中）   磁碟上會有：boot block、volume control（superblock 概念）、每個檔案的 inode/FCB、目錄內容   記憶體中會有：mount table、directory cache、system-wide open-file table、per-process fd table   目的都是讓「路徑解析、開檔、讀寫」變快，同時維持一致性     檔案資料實際要怎麼放到磁碟 blocks？空閒空間怎麼管理？（本章超級考點）   配置方法重點比較：   Contiguous（快但外部碎裂、成長不易）   Li...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">YowDesert</div><div class="author-info-description">這是YowDesert的部落格，記錄學習資訊工程領域的過程和心得，並以簡單白話的方式呈現，一起和我踏入資訊世界吧，有興趣的話歡迎Follow我歐。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yowdesert"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yowdesert" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:csaidesert@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前導</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">摘要</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BackGround"><span class="toc-number">2.1.</span> <span class="toc-text">BackGround</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Management-Issues"><span class="toc-number">2.2.</span> <span class="toc-text">Memory Management Issues</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multistep-Processing"><span class="toc-number">2.3.</span> <span class="toc-text">Multistep Processing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Address Binding</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Compile-Time%EF%BC%88%E7%B7%A8%E8%AD%AF%E6%9C%9F%E7%B6%81%E5%AE%9A%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">Compile Time（編譯期綁定）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Load-Time%EF%BC%88%E8%BC%89%E5%85%A5%E6%9C%9F%E7%B6%81%E5%AE%9A%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">Load Time（載入期綁定）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Execution-Time%EF%BC%88%E5%9F%B7%E8%A1%8C%E6%9C%9F%E7%B6%81%E5%AE%9A%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">Execution Time（執行期綁定）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Management-Unit-MMU"><span class="toc-number">3.4.</span> <span class="toc-text">Memory-Management Unit(MMU)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Logical-v-s-Physical-Address"><span class="toc-number">3.5.</span> <span class="toc-text">Logical v.s. Physical Address</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Load Program  into Memory → static&#x2F;dynamic loading &amp; linking</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Loading"><span class="toc-number">4.1.</span> <span class="toc-text">Dynamic Loading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-Linking"><span class="toc-number">4.2.</span> <span class="toc-text">Static Linking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Linking"><span class="toc-number">4.3.</span> <span class="toc-text">Dynamic Linking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-Dynamic-Loading-Linking%EF%BC%9AFour-Combinations"><span class="toc-number">4.4.</span> <span class="toc-text">Static &#x2F; Dynamic Loading &amp; Linking：Four Combinations</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Swapping</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E7%BE%A9"><span class="toc-number">5.1.</span> <span class="toc-text">定義 :</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swap-back-Memory-Address-Requirements"><span class="toc-number">5.2.</span> <span class="toc-text">Swap-back Memory Address Requirements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swapping-I-O-Problem"><span class="toc-number">5.3.</span> <span class="toc-text">Swapping: I&#x2F;O Problem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Solution-to-I-O-Swapping-Conflict"><span class="toc-number">5.4.</span> <span class="toc-text">Solution to I&#x2F;O-Swapping Conflict:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-1-Never-swap-processes-with-pending-I-O"><span class="toc-number">5.4.1.</span> <span class="toc-text">Solution 1 : Never swap processes with pending I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-2-Use-OS-managed-I-O-buffers%EF%BC%88kernel-buffer%EF%BC%89"><span class="toc-number">5.4.2.</span> <span class="toc-text">Solution 2 : Use OS-managed I&#x2F;O buffers（kernel buffer）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Process-Swapping-to-Backing-Store"><span class="toc-number">5.5.</span> <span class="toc-text">Process Swapping to Backing Store</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Memory Allocation Schemes (連續記憶體配置)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Fixed-Partition-Allocation"><span class="toc-number">6.1.</span> <span class="toc-text">Fixed-Partition Allocation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Variable-Partition-Allocation"><span class="toc-number">6.2.</span> <span class="toc-text">Variable-Partition Allocation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multiple-Partition-Variable-Size-Method%EF%BC%88%E5%8F%AF%E8%AE%8A%E5%88%86%E5%89%B2%E5%88%B0%E5%BA%95%E6%80%8E%E9%BA%BC%E9%81%8B%E4%BD%9C%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">Multiple Partition (Variable-Size) Method（可變分割到底怎麼運作）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Storage-Allocation-Problem"><span class="toc-number">6.4.</span> <span class="toc-text">Dynamic Storage Allocation Problem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Fragmentation"><span class="toc-number">6.5.</span> <span class="toc-text">Memory Fragmentation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#External-Fragmentation%EF%BC%88%E5%A4%96%E9%83%A8%E7%A2%8E%E8%A3%82%EF%BC%89"><span class="toc-number">6.5.1.</span> <span class="toc-text">External Fragmentation（外部碎裂）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Internal-Fragmentation%EF%BC%88%E5%85%A7%E9%83%A8%E7%A2%8E%E8%A3%82%EF%BC%89"><span class="toc-number">6.5.2.</span> <span class="toc-text">Internal Fragmentation（內部碎裂）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-Memory-Compaction"><span class="toc-number">6.5.3.</span> <span class="toc-text">Solution : Memory Compaction</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Non-Contiguous Memory Allocation - Paging</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Paging-Concept"><span class="toc-number">7.1.</span> <span class="toc-text">Paging Concept</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Paging-%E7%9A%84-4-%E5%A4%A7%E5%A5%BD%E8%99%95"><span class="toc-number">7.2.</span> <span class="toc-text">Paging 的 4 大好處</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-table-fundamentals"><span class="toc-number">7.3.</span> <span class="toc-text">Page table fundamentals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Address-Translation-Scheme"><span class="toc-number">7.4.</span> <span class="toc-text">Address Translation Scheme</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Address-Translation"><span class="toc-number">7.5.</span> <span class="toc-text">Address Translation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Frame-Size-Considerations"><span class="toc-number">7.6.</span> <span class="toc-text">Page&#x2F;Frame Size Considerations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Paging-Summary"><span class="toc-number">7.7.</span> <span class="toc-text">Paging Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">Implementation of Page Table</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Associative-Memory-CAM"><span class="toc-number">8.1.</span> <span class="toc-text">Associative Memory &#x2F; CAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Translation-Lookaside-Buffer-TLB"><span class="toc-number">8.2.</span> <span class="toc-text">Translation Lookaside Buffer (TLB)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EMAT%EF%BC%88Effective-Memory-Access-Time%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">EMAT（Effective Memory-Access Time）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Protection%EF%BC%88Page-table-entry-%E8%A3%A1%E7%9A%84%E4%BF%9D%E8%AD%B7%E4%BD%8D%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">Memory Protection（Page table entry 裡的保護位）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shared-Pages"><span class="toc-number">8.5.</span> <span class="toc-text">Shared Pages</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shared-Pages-via-Page-Tables"><span class="toc-number">8.6.</span> <span class="toc-text">Shared Pages via Page Tables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Table-Structure%EF%BC%9AScalability-Problem"><span class="toc-number">8.7.</span> <span class="toc-text">Page Table Structure：Scalability Problem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hierarchical-Paging%E3%80%81Hashed-Page-Table%E3%80%81Inverted-Page-Table-IPT"><span class="toc-number">8.8.</span> <span class="toc-text">Hierarchical Paging、Hashed Page Table、Inverted Page Table, IPT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hierarchical-paging%E7%9A%84%E7%9B%AE%E6%A8%99%EF%BC%9A%E3%80%8C%E9%A0%81%E8%A1%A8%E4%B8%8D%E8%A6%81%E4%B8%80%E6%AC%A1%E6%95%B4%E5%BC%B5%E9%83%BD%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%94%A8%E5%88%B0%E5%93%AA%E4%B8%80%E6%AE%B5%E6%89%8D%E9%96%8B%E5%93%AA%E4%B8%80%E6%AE%B5%E3%80%82%E3%80%8D"><span class="toc-number">8.8.1.</span> <span class="toc-text">Hierarchical paging的目標：「頁表不要一次整張都配置，用到哪一段才開哪一段。」</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashed-page-table-%E6%83%B3%E7%94%A8-hash-%E7%9B%B4%E6%8E%A5%E8%B7%B3%E5%88%B0%E3%80%8C%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BD%8D%E7%BD%AE%E3%80%8D%EF%BC%8C%E5%B0%91%E8%B5%B0%E5%A5%BD%E5%B9%BE%E5%B1%A4%E3%80%82"><span class="toc-number">8.8.2.</span> <span class="toc-text">Hashed page table : 想用 hash 直接跳到「可能的位置」，少走好幾層。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inverted-Page-Table"><span class="toc-number">8.8.3.</span> <span class="toc-text">Inverted Page Table</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">Segmentation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Segmentation-Table%EF%BC%88%E5%88%86%E6%AE%B5%E8%A1%A8%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">Segmentation Table（分段表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E9%AB%94%E6%9A%AB%E5%AD%98%E5%99%A8%EF%BC%9ASTBR-STLR"><span class="toc-number">9.2.</span> <span class="toc-text">硬體暫存器：STBR &#x2F; STLR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Translation"><span class="toc-number">9.3.</span> <span class="toc-text">Translation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MMU-%E6%9C%83%E5%81%9A%E4%B8%89%E4%BB%B6%E4%BA%8B"><span class="toc-number">9.4.</span> <span class="toc-text">MMU 會做三件事</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segmentation-vs-Paging"><span class="toc-number">9.5.</span> <span class="toc-text">Segmentation vs Paging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sharing-of-Segments"><span class="toc-number">9.6.</span> <span class="toc-text">Sharing of Segments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Protection-and-Sharing-in-Segmentation"><span class="toc-number">9.7.</span> <span class="toc-text">Protection and Sharing in Segmentation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">Segmentation with Paging</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2afc752c.html" title="[日文] 日文學習-初級1-文法">[日文] 日文學習-初級1-文法</a><time datetime="2026-01-05T04:00:00.000Z" title="發表於 2026-01-05 12:00:00">2026-01-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/c7d4007f.html" title="[日文] 日文學習-初級2-單字">[日文] 日文學習-初級2-單字</a><time datetime="2026-01-05T04:00:00.000Z" title="發表於 2026-01-05 12:00:00">2026-01-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/918b2cda.html" title="[日文] 日文學習-初級1-單字">[日文] 日文學習-初級1-單字</a><time datetime="2025-12-31T08:45:00.000Z" title="發表於 2025-12-31 16:45:00">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/a47372cf.html" title="[日文] 日文學習-初級2-文法">[日文] 日文學習-初級2-文法</a><time datetime="2025-12-31T08:45:00.000Z" title="發表於 2025-12-31 16:45:00">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/cf6482ff.html" title="(作業系統) File System">(作業系統) File System</a><time datetime="2025-12-21T05:15:00.000Z" title="發表於 2025-12-21 13:15:00">2025-12-21</time></div></div></div></div><div class="card-widget ads-wrap"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5975504062599634" crossorigin="anonymous"></script> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5975504062599634" data-ad-slot="9206833147" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></div></div></div></main><footer id="footer" style="background-image: url(/img/nav_Picture.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By YowDesert</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主題 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="/"></script></div></body></html>